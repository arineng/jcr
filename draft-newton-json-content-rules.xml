<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "http://xml2rfc.tools.ietf.org/authoring/rfc2629.dtd"
[
  <!ENTITY RFC1166 PUBLIC ''
   'http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.1166.xml'>
  <!ENTITY RFC3339 PUBLIC ''
   'http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3339.xml'>
  <!ENTITY RFC3986 PUBLIC ''
   'http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3986.xml'>
  <!ENTITY RFC4234 PUBLIC ''
   'http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4234.xml'>
  <!ENTITY RFC4627 PUBLIC ''
   'http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4627.xml'>
  <!ENTITY RFC4648 PUBLIC ''
   'http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4648.xml'>
  <!ENTITY RFC5322 PUBLIC ''
   'http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5322.xml'>
  <!ENTITY RFC5952 PUBLIC ''
   'http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5952.xml'>
  <!ENTITY RFC7492 PUBLIC ''
   'http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7492.xml'>
  <!ENTITY RFC8259 PUBLIC ''
   'http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.8259.xml'>
  <!ENTITY I-D.cordell-jcr-co-constraints PUBLIC ''
   'http://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.cordell-jcr-co-constraints.xml'>
   
  <!ENTITY ABNF PUBLIC ''
    'jcr-abnf.txt'>
  <!ENTITY first_example.json PUBLIC ''
    'figs/first_example.json'>
  <!ENTITY first_example.jcr PUBLIC ''
    'figs/first_example.jcr'>
  <!ENTITY first_example2.jcr PUBLIC ''
    'figs/first_example2.jcr'>   
  <!ENTITY second_example.json PUBLIC ''
    'figs/second_example.json'>   
  <!ENTITY second_example.jcr PUBLIC ''
    'figs/second_example.jcr'>   
  <!ENTITY second_example2.jcr PUBLIC ''
    'figs/second_example2.jcr'>   
  <!ENTITY second_example_override.jcr PUBLIC ''
    'figs/second_example_override.jcr'>   
  <!ENTITY rfc4627_example.json PUBLIC ''
    'figs/rfc4627_example.json'>   
  <!ENTITY rfc4627_example.jcr PUBLIC ''
    'figs/rfc4627_example.jcr'>   
  <!ENTITY rfc4627_example2.jcr PUBLIC ''
    'figs/rfc4627_example2.jcr'>   
  <!ENTITY rule_name_ruleset_id.jcr PUBLIC ''
    'figs/rule_name_ruleset_id.jcr'>
  <!ENTITY assignment_example.jcr PUBLIC ''
    'figs/assignment_example.jcr'>
  <!ENTITY annotation_example.jcr PUBLIC ''
    'figs/annotation_example.jcr'>
  <!ENTITY primitives_overview.jcr PUBLIC ''
    'figs/primitives_overview.jcr'>
  <!ENTITY primitives_boolean_and_null.jcr PUBLIC ''
    'figs/primitives_boolean_and_null.jcr'>
  <!ENTITY primitives_integer_and_float.jcr PUBLIC ''
    'figs/primitives_integer_and_float.jcr'>
  <!ENTITY primitives_float_range.jcr PUBLIC ''
    'figs/primitives_float_range.jcr'>
  <!ENTITY primitives_bit_integers.jcr PUBLIC ''
    'figs/primitives_bit_integers.jcr'>
  <!ENTITY primitives_strings.jcr PUBLIC ''
    'figs/primitives_strings.jcr'>
  <!ENTITY primitives_uris.jcr PUBLIC ''
    'figs/primitives_uris.jcr'>
  <!ENTITY primitives_misc.jcr PUBLIC ''
    'figs/primitives_misc.jcr'>
  <!ENTITY primitives_binary.jcr PUBLIC ''
    'figs/primitives_binary.jcr'>
  <!ENTITY member_specifications.jcr PUBLIC ''
    'figs/member_specifications.jcr'>
  <!ENTITY object_example.jcr PUBLIC ''
    'figs/object_example.jcr'>
  <!ENTITY object_example1.json PUBLIC ''
    'figs/object_example1.json'>
  <!ENTITY object_example2.json PUBLIC ''
    'figs/object_example2.json'>
  <!ENTITY object_order_eval.json PUBLIC ''
    'figs/object_order_eval.json'>
  <!ENTITY object_order_eval.jcr PUBLIC ''
    'figs/object_order_eval.jcr'>
  <!ENTITY array_example.jcr PUBLIC ''
    'figs/array_example.jcr'>
  <!ENTITY array_order_eval.jcr PUBLIC ''
    'figs/array_order_eval.jcr'>
  <!ENTITY array_order_eval.json PUBLIC ''
    'figs/array_order_eval.json'>
  <!ENTITY array_order_eval2.json PUBLIC ''
    'figs/array_order_eval2.json'>
  <!ENTITY array_unordered_eval.jcr PUBLIC ''
    'figs/array_unordered_eval.jcr'>
  <!ENTITY group_example.jcr PUBLIC ''
    'figs/group_example.jcr'>
  <!ENTITY and_or_example.jcr PUBLIC ''
    'figs/and_or_example.jcr'>
  <!ENTITY mixed_and_or_bad.jcr PUBLIC ''
    'figs/mixed_and_or_bad.jcr'>
  <!ENTITY mixed_and_or_good.jcr PUBLIC ''
    'figs/mixed_and_or_good.jcr'>
  <!ENTITY repetition_min_max.jcr PUBLIC ''
    'figs/repetition_min_max.jcr'>
  <!ENTITY repetition_kleene.jcr PUBLIC ''
    'figs/repetition_kleene.jcr'>
  <!ENTITY repetition_step.jcr PUBLIC ''
    'figs/repetition_step.jcr'>
  <!ENTITY not_annotation.jcr PUBLIC ''
    'figs/not_annotation.jcr'>
  <!ENTITY single_line_directive_example.jcr PUBLIC ''
    'figs/single_line_directive_example.jcr'>
  <!ENTITY multi_line_directive_example.jcr PUBLIC ''
    'figs/multi_line_directive_example.jcr'>
  <!ENTITY jcr_version_current.jcr PUBLIC ''
    'figs/jcr_version_current.jcr'>
  <!ENTITY ruleset_id.jcr PUBLIC ''
    'figs/ruleset_id.jcr'>
  <!ENTITY any_member.jcr PUBLIC ''
    'figs/any_member.jcr'>
  <!ENTITY any_member1.json PUBLIC ''
    'figs/any_member1.json'>
  <!ENTITY any_member2.json PUBLIC ''
    'figs/any_member2.json'>
  <!ENTITY any_member_any_type.jcr PUBLIC ''
    'figs/any_member_any_type.jcr'>
  <!ENTITY any_member_any_type2.json PUBLIC ''
    'figs/any_member_any_type2.json'>
  <!ENTITY restrict_objects.jcr PUBLIC ''
    'figs/restrict_objects.jcr'>
  <!ENTITY restrict_objects1.json PUBLIC ''
    'figs/restrict_objects1.json'>
  <!ENTITY restrict_objects2.json PUBLIC ''
    'figs/restrict_objects2.json'>
  <!ENTITY unrestricted_arrays.jcr PUBLIC ''
    'figs/unrestricted_arrays.jcr'>
  <!ENTITY lists_of_values.jcr PUBLIC ''
    'figs/lists_of_values.jcr'>
  <!ENTITY groups_in_arrays.jcr PUBLIC ''
    'figs/groups_in_arrays.jcr'>
  <!ENTITY groups_in_arrays2.jcr PUBLIC ''
    'figs/groups_in_arrays2.jcr'>
  <!ENTITY groups_in_objects.jcr PUBLIC ''
    'figs/groups_in_objects.jcr'>
  <!ENTITY groups_in_objects_ignored.json PUBLIC ''
    'figs/groups_in_objects_ignored.json'>
  <!ENTITY groups_in_objects_ignored1.jcr PUBLIC ''
    'figs/groups_in_objects_ignored1.jcr'>
  <!ENTITY groups_in_objects_ignored2.jcr PUBLIC ''
    'figs/groups_in_objects_ignored2.jcr'>
  <!ENTITY groups_in_objects_ignored3.jcr PUBLIC ''
    'figs/groups_in_objects_ignored3.jcr'>
  <!ENTITY macro.jcr PUBLIC ''
    'figs/macro.jcr'>
  <!ENTITY object_mixin.jcr PUBLIC ''
    'figs/object_mixin.jcr'>
  <!ENTITY subordinate_dependents.jcr PUBLIC ''
    'figs/subordinate_dependents.jcr'>
  <!ENTITY override1.jcr PUBLIC ''
    'figs/override1.jcr'>
  <!ENTITY override1.json PUBLIC ''
    'figs/override1.json'>
  <!ENTITY override2.jcr PUBLIC ''
    'figs/override2.jcr'>
  <!ENTITY override2.json PUBLIC ''
    'figs/override2.json'>
  <!ENTITY override3.jcr PUBLIC ''
    'figs/override3.jcr'>
]>
<?rfc toc="yes"?>
<rfc category="std" docName="draft-newton-json-content-rules-10" ipr="trust200902">
    <front>
        <title abbrev="JSON Content Rules">A Language for Rules Describing JSON Content</title>
        <author fullname="Andrew Lee Newton" initials="A.L." surname="Newton">
            <organization abbrev="ARIN">American Registry for Internet Numbers</organization>
            <address>
                <postal>
                    <street>PO Box 232290</street>
                    <city>Centreville</city>
                    <region>VA</region>
                    <country>US</country>
                    <code>20120</code>
                </postal>
                <email>andy@arin.net</email>
                <uri>http://www.arin.net</uri>
            </address>
        </author>
        <author fullname="Pete Cordell" initials="P." surname="Cordell">
            <organization>Codalogic</organization>
            <address>
                <postal>
                    <street>PO Box 30</street>
                    <city>Ipswich</city>
                    <country>UK</country>
                    <code>IP5 2WY</code>
                </postal>
                <email>pete.cordell@codalogic.com</email>
                <uri>http://www.codalogic.com</uri>
            </address>
        </author>
        <date/>
        <abstract>
            <t>
                This document describes a language for specifying and testing the expected content of JSON structures
                found in JSON-using protocols, software, and processes.
            </t>
        </abstract>
    </front>
    <middle>
        <section title="Motivation">
            <t>
                As a growing number of protocols use JSON, there is an increasing need to find better mechanisms
                to help define such protocols.
            </t>
            <t>
                In the past, protocols often used constrained alphabet strings. Such strings could be defined by
                example, but it was found better to use Backus-Naur Form (BNF), or variants such
                as ABNF. The benefit of using ABNF over examples is that the full variation of what is allowed in a
                protocol can be expressed in a single location. This leads to easier implementation and better
                interoperability.
            </t>
            <t>
                As protocols migrate to being defined in JSON, the same need to define the valid set of JSON
                messages arises. It is conceivable to define the JSON-based message set by way of examples. But as
                with constrained alphabet strings, this can be cumbersome, incomplete and easily misinterpreted,
                leading to the problems of implementation and interoperability mentioned earlier.
            </t>
            <t>
                It would be theoretically possible to express the valid set of a protocolâ€™s JSON messages using ABNF.
                However, ABNF is difficult to get right at the best of times, and defining an ABNF that simultaneously
                interwove the constraints of JSON and the constraints of the protocol into a single ABNF definition
                would be a task few could, or would, want to achieve. Even if such were possible, much of what was
                intended to describe the protocol, would be obscured by the aspects describing the JSON
                constraints. Such an approach is likely to end up being only comprehendible by a machine, and be
                impenetrable to humans. As such, arguably, such a definition would not satisfy it primary target
                audience.
            </t>
            <t>
                The solution is to move up a level of abstraction. In the same way JSON is a level of abstraction
                above constrained alphabet strings for representing protocols, a similar move up in abstraction level
                is needed for the mechanism used to define such protocols.
            </t>
            <t>
                JSON Content Rules (JCR) is such a step up in abstraction. Itâ€™s relation to JSON is that of ABNF to
                constrained string alphabets. By â€˜knowingâ€™ about JSON it can more accurately and concisely define
                JSON messages than other methods that are less abstracted. In the same way that abstracted
                languages such as Java and Python enable a programmer to work more efficiently than they can with
                assembler, protocol developers can work more efficiently using JCR than they can with ABNF.
            </t>
            <t>
                That said, JCR is not the only language in this space nor the only solution, beyond ABNF, to this
                problem. Of the various method and languages that the authors know about, in addition to JCR,
                there are format translators which algorithmically convert a specification from one format to
                another (e.g. XML to JSON), abstraction languages such as Yang and CDDL, and at least one other JSON
                specific language: JSON Schema.
            </t>
            <section title="Format Translation">
                <t>
                    Format translation is an algorithmic approach to specifying protocol messages in multiple formats
                    by using one format as the base specification and an algorithm for translating that formatting
                    into another. One example would be the translation of XML into JSON using the BadgerFish
                    algorithm and software.
                </t>
                <t>
                    This approach often creates difficult protocol messages in the destination format (i.e. JSON in
                    the case of XML to JSON) which are hard to implement towards or debug. Additionally, while it be
                    fashionable to have multiple formats, most software implementations of protocols work best with
                    one format and often not well with others if at all.
                </t>
                <t>
                    vCard and jCard are good examples of this. The original format and data model for vCard
                    are specified in MIME. jCard is an algorthmic conversion of vCard to jCard. Consequently,
                    writing software implementations of jCard requires software developers to have an intimate
                    knowledge of MIME, saving them little in the way of time or effort.
                </t>
            </section>
            <section title="Abstraction Languages">
                <t>
                    Abstraction languages are nothing new to the schema and data definition language space, with ASN.1
                    being a classic example of specifying a data model in a higher level syntax and defined algorithms
                    for multiple data formats. ASN.1 has many, such as BER and DER and XER (XML Encoding Rules).
                    Yang is a more modern and popular abstraction languages.
                </t>
                <t>
                    These languages have their place but suffer the same issues as format translators as they
                    require software implementors to spend valuable energy on a syntax that is not specific to the
                    software being implemented. Additionally, abstraction languages have, in many instances, specified
                    features in the data model that do not translate well to all data formats or may lack compelling
                    features because the langauge must cater to multiple formats.
                </t>
                <t>
                    With respect to JSON, CDDL is an abstraction language as it's data model is a superset of the
                    data model of JSON. In other words, it is possible to specify protocol messages in CDDL that are
                    not applicable to JSON. And because CDDL targets CBOR specifically, it does not benefit from being
                    a superset of JSON, as is the case of JCR, or specified in JSON, as is the case of JSON Schema.
                </t>
            </section>
            <section title="JSON Schema vs JCR">
                <t>
                    JSON Schema, like JCR, is a data definition language designed specifically for JSON. And while JCR
                    is more tightly scoped to defining JSON protocol messages and content, JSON Schema is more
                    broadly scoped in its goals. From a high-level view point, it could be said that JSON Schema is
                    like XML Schema whereas JCR is more like Compact RelaxNG.
                </t>
                <t>
                    JSON Schema benefits from being defined in JSON (as this makes implementations of JSON Schema tools
                    easier), but this benefit impacts readability of specifications defining content using it. To
                    demonstrate, the following examples define JSON using the classic example of a catolog object.
                </t>
                <figure anchor="example_catalog_json_schema">
                    <preamble>
                        In this example, the catalog entry is defined in JSON Schema.
                    </preamble>
                    <artwork xml:space="preserve" align="center">
{
  "$schema": "http://json-schema.org/draft-06/schema#",
  "title": "Product",
  "description": "A product from Acme&#39;s catalog",
  "type": "object",
  "properties": {
    "id": {
      "description": "The unique identifier for a product",
      "type": "integer"
    },
    "name": {
      "description": "Name of the product",
      "type": "string"
    },
    "price": {
      "type": "number",
      "exclusiveMinimum": 0
    },
    "tags": {
      "type": "array",
      "items": {
      "type": "string"
    },
    "minItems": 1,
    "uniqueItems": true
    }
  },
  "required": ["id", "name", "price"]
}
                    </artwork>
                </figure>
                <figure anchor="example_catalog_jcr">
                    <preamble>
                        For comparison, this example demonstrates the same catalog
                        entry as described in <xref target="example_catalog_json_schema"></xref>
                        but in JCR.
                    </preamble>
                    <artwork xml:space="preserve" align="center">
#jcr-version 0.9
; Product â€“ A Product for Acmeâ€™s catalog
{
  "id"    : integer,      ; Unique identifier for the product
  "name"  : string,       ; Name of the product
  "price" : @{minExclusive} 0.0..,
  "tags"  : [ string + ] ?
}
                    </artwork>
                </figure>
                <t>
                    The above examples demonstrate that the JCR is more concise and conveys the same
                    information but in fewer lines in a syntax familiar with a JSON-aware software
                    implementor.
                </t>
                <t>
                    Additionally, JCR is a superset of JSON whereby specification authors may use example
                    JSON protocol messages as a starting point for defining JCR rules (as is described in
                    <xref target="a_first_example"></xref>). Combined with the brevity of describing rules
                    and the ability to name rules, specification authors may also interleave their prose
                    with JCR rules in their specifications thus describing semantics in close proximity
                    to syntax.
                </t>
            </section>
        </section>
        <section title="Introduction">
            <t>
                This document describes JSON Content Rules (JCR), a language
                for specifying and testing the interchange of data
                in <xref target="RFC8259">JSON</xref> format used by computer protocols and processes.
                The syntax of JCR is not JSON but is "JSON-like", possessing the conciseness and
                utility that has made JSON popular.
            </t>
            <section title="A First Example: Specifying Content" anchor="a_first_example">
                <t>
                    The following JSON data describes a JSON object with two members, "line-count" and
                    "word-count", each containing an integer.                    
                </t>
                <figure anchor="first_example.json">
                    <artwork xml:space="preserve" align="center">&first_example.json;</artwork>
                </figure>
                <t>
                    This is also JCR that describes a JSON object with a member named "line-count" that is
                    an integer that is exactly 3426 and a member named "word-count" that is an integer that
                    is exactly 27886.
                </t>
                <t>
                    For a protocol specification, it is probably more useful to specify that each member
                    is any integer and not specific, exact integers:
                </t>
                <figure anchor="first_example.jcr">
                    <artwork xml:space="preserve" align="center">&first_example.jcr;</artwork>
                </figure>
                <t>
                    Since line counts and word counts should be either zero or a positive integer,
                    the specification may be further narrowed:
                </t>                
                <figure anchor="first_example2.jcr">
                    <artwork xml:space="preserve" align="center">&first_example2.jcr;</artwork>
                </figure>
            </section>
            <section title="A Second Example: Testing Content">
                <t>
                    Building on the first example, this second example describes the same object
                    but with the addition of another member, "file-name".
                </t>
                <figure anchor="second_example.json">
                    <artwork xml:space="preserve" align="center">&second_example.json;</artwork>
                </figure>                
                <t>
                    The following JCR describes objects like it.
                </t>
                <figure anchor="second_example.jcr">
                    <artwork xml:space="preserve" align="center">&second_example.jcr;</artwork>
                </figure>                
                <t>
                    For the purposes of writing a protocol specification, JCR may be broken down into
                    named rules to reduce complexity and to enable re-use. The following example takes
                    the JCR from above and rewrites the members as named rules.
                </t>
                <figure anchor="second_example2.jcr">
                    <artwork xml:space="preserve" align="center">&second_example2.jcr;</artwork>
                </figure>                
                <t>
                    With each member specified as a named rule, software testers can override them locally
                    for specific test cases. In the following example, the named rules are locally overridden
                    for the test case where the file name is "rfc4627.txt".
                </t>                
                <figure anchor="second_example_override.jcr">
                    <artwork xml:space="preserve" align="center">&second_example_override.jcr;</artwork>
                </figure>      
                <t>
                    In this example, the protocol specification describes the JSON object in general and
                    an implementation overrides the rules for testing specific cases.
                </t>
                <t>
                    All figures used in this specification are available <eref target="https://github.com/arineng/jcr/tree/master/figs">here</eref>.
                </t>
            </section>
        </section>
        <section title="Overview of the Language">
            <t>
                JCR is composed of rules (as the name suggests). A collection of rules that is processed
                together is a ruleset. Rulesets may also contain comments, blank lines, and directives
                that apply to the processing of a ruleset.
            </t>
            <t>
                Rules are composed of two parts, an optional rule name and
                a rule specification.  A rule specification can be either a type
                specification or a member specification.  A member specification
                consists of a member name specification and a type specification.
            </t>
            <t>
                A type specification is used to specify constraints on a superset
                of a JSON value (e.g. number / string / object / array etc.).  In
                addition to defining primitive types (such as string or integer),
                array types, and object types, type specifications may define the
                JCR specific concept of group types.
            </t>
            <t>
                Type specifications corresponding to arrays, objects and groups may
                be composed of other rule specifications.
            </t>
            <t>
                A member specification is used to specify constraints on a JSON
                member (i.e. members of a JSON object).
            </t>
            <t>
                Rules with rule name assignments may be referenced in place of
                type specifications and member specifications.
            </t>
            <t>
                Rules may be defined across line boundaries and there is no line
                continuation syntax. 
            </t>
            <t>
                Any rule consisting only of a type specification is considered a root rule. Unless otherwise
                specified, all the root rules of a ruleset are evaluated against a JSON instance or document.
            </t>
            <t>
                Putting it all together, <xref target="rfc4627-example-1-compact-rules"></xref>
                describes the JSON in <xref target="rfc4627-example-1"></xref>.
            </t>
            <figure anchor="rfc4627-example-1">
                <preamble>Example JSON shamelessly lifted from RFC 4627</preamble>
                <artwork xml:space="preserve" align="center">&rfc4627_example.json;</artwork>
            </figure>
            <figure anchor="rfc4627-example-1-compact-rules">
                <preamble>Rules describing <xref target="rfc4627-example-1"></xref></preamble>
                <artwork xml:space="preserve" align="center">&rfc4627_example2.jcr;</artwork>
            </figure>
        </section> 
        <section title="Lines and Comments">
            <t>
                There is no statement terminator and therefore no need for a line continuation syntax.
                Rules may be defined across line boundaries.
                Blank lines are allowed.
            </t>
            <t>
                Comments are the same as comments in <xref target="RFC4234">ABNF</xref>. They start with a semi-colon (';') and
                continue to the end of the line.
            </t>
        </section>
        <section title="Rules">
            <t>
                Rules have two main components, an optional rule name assignment and a type or member specification.
            </t>
            <t>
                Type specifications define arrays, objects, etc... of JSON and may reference other rules
                using rule names. Most type specifications can be defined with repetitions for specifying
                the frequency of the type being defined. In addition to the type specifications describing
                JSON types, there is an additional group specification for grouping types.
            </t>
            <t>
                Member specifications define members of JSON objects, and are composed of a member name specification
                and either a type specification or a rule name referencing a type specification.
            </t>
            <t>
                Rules may also contain annotations which may affect the evaluation of all or part of a rule.
                Rules without a rule name assignment are considered root rules, though rules with a rule
                name assignment can be considered a root rule with the appropriate annotation.
            </t>
            <t>
                Type specifications, depending on their type, can contain zero or more other
                specifications or rule names. For example, an object specification might contain multiple
                member specifications or rule names that resolve to member specifications or a mixture
                of member specifications and rule names. For the purposes of this document, specifications
                and rule names composing other specifications are called subordinate components.
            </t>
            <section title="Rule Names and Assignments">
                <t>
                    Rule names are signified with the dollar character ('$'), which is not part of the
                    rule name itself. Rule names have two components, an optional ruleset identifier alias and a local
                    rule name.
                </t>
                <t>
                    Local rule names must start with an alphabetic character (a-z,A-Z) and must contain only
                    alphabetic characters, numeric characters, the hyphen character ('-') and the
                    underscore character ('_'). Local rule names are case sensitive, and must be unique
                    within a ruleset (that is, no two rule name assignments may use the same local rule name).
                </t>
                <t>
                    Ruleset identifier aliases enable referencing rules from another ruleset. They are not allowed in rule
                    name assignments, and only found in rule names referencing other rules. Ruleset identifiers must start with
                    an alphabetic character and contain no whitespace. Ruleset identifiers are case sensitive.
                    Simple use cases of JCR will most likely not use ruleset identifiers.
                </t>
                <figure anchor="rule_name_ruleset_id.jcr">
                    <preamble>
                        In Figure 10 below,
                        "http://ietf.org/rfcYYYY.JCR" and "http://ietf.org/rfcXXXX.JCR" are ruleset 
                        identifiers and "rfcXXXX" is a ruleset identifier alias.
                    </preamble>
                    <artwork align="center" xml:space="preserve">&rule_name_ruleset_id.jcr;</artwork>
                </figure>
                <t>
                    Rule name assignments separate the rule name from the type specification using the '='
                    character. Rule name assignments to primitive type specifications may optionally use
                    the character sequence '=:'.
                </t>
                <figure anchor="assignment_example.jcr">
                    <artwork xml:space="preserve" align="center">&assignment_example.jcr;</artwork>
                </figure>
                <t>
                    The optional syntax for rule name assignments to primitive type specifications allows
                    backwards compatibility with earlier versions of JCR in which this syntax was required.
                </t>
            </section>
            <section title="Annotations">
                <t>
                    Annotations may appear before a rule name assignment, before a type or member specification, or
                    before a rule name contained within a type specification. In each place, there may be
                    zero or more annotations.
                    Each annotation begins with the
                    character sequence "@{" and ends with "}". The following is an example of a type specification
                    with the not annotation (explained in <xref target="not_annotation"></xref>):
                </t>
                <figure anchor="annotation_example.jcr">
                    <artwork xml:space="preserve" align="center">&annotation_example.jcr;</artwork>
                </figure>
                <t>
                    This specification defines the annotations "root", "not", and "unordered", but
                    other annotations may be defined for other purposes.
                </t>
            </section>
            <section title="Starting Points and Root Rules" anchor="starting-points">
                <t>
                    Evaluation of a JSON instance or document against a ruleset begins with the evaluation of
                    a root rule or set of root rules. If no root rule (or rules) is specified locally at
                    runtime, the set of root rules specified in the ruleset are evaluated. The order of
                    evaluation is undefined.
                </t>
                <t>
                    The set of root rules specified in a ruleset is composed of all rules without a rule
                    name assignment and all rules annotated with the "@{root}" annotation.
                </t>
                <t>
                    The "@{root}" annotation may either appear before a rule name assignment or before
                    a type definition. It is ignored if present before referenced rule name inside of a
                    type specification.
                </t>
            </section>
            <section title="Type Specifications">
                <t>
                    The syntax of each type of type specifications varies depending on the type:
                </t>
                <figure anchor="primitive_overview.jcr">
                    <artwork xml:space="preserve" align="center">&primitives_overview.jcr;</artwork>
                </figure>
            </section>
            <section title="Primitive Specifications">
            <t>
                Primitive type specifications define content for JSON numbers, booleans, strings, and null.
            </t>
            <section title="Numbers, Booleans and Null">
            <t>
                The rules for booleans and null are the simplest and take the following forms:
            </t>
            <figure anchor="primitive_boolean_and_null.jcr">
                <artwork xml:space="preserve" align="center">&primitives_boolean_and_null.jcr;</artwork>
            </figure>
                <t>
                Rules for numbers can specify the number be either an integer or floating point number:
                </t>
                <figure anchor="primitive_integer_and_float.jcr">
                    <artwork xml:space="preserve" align="center">&primitives_integer_and_float.jcr;</artwork>
                </figure>
                <t>
                    The keyword 'float' represents a single precision IEEE-754 floating point number 
                    represented in decimal. The keyword 'double' represents a double precision 
                    IEEE-754 floating point number represented in decimal format.
                </t>
                <t>
                Numbers may also be specified as an absolute value or a range of possible values, where a range
                may be specified using a minimum, maximum, or both:
                </t>
                <figure anchor="n_to_m">
                    <artwork align="center" xml:space="preserve">
  n
  n..m
   ..m
  n..
n.f
n.f..m.f
   ..m.f
n.f..
                    </artwork>
                </figure>
                <t>
                When specifying a minimum and a maximum, both must either be an integer or a floating point number.
                Thus to specify a floating point number between zero and ten a definition of the following form is used:
            </t>
            <figure anchor="primitive_float_range.jcr">
                <artwork xml:space="preserve" align="center">&primitives_float_range.jcr;</artwork>
            </figure>  
                <t>
                    Integers may also be specified as ranges using bit lengths preceded by the 'int' or 'uint'
                    words (i.e. 'int8', 'uint16'). The 'int' prefix specifies the integer as being signed whereas
                    the 'uint' prefix specifies the integer as being unsigned.
                </t>
                <figure anchor="primitive_bit_integers.jcr">
                    <artwork xml:space="preserve" align="center">&primitives_bit_integers.jcr;</artwork>
                </figure>  
            </section>
            <section title="Strings">
                <t>
                    JCR provides a large number of data types to define the contents of JSON strings.
                    Generically, a string may be specified using the word 'string'. String literals
                    may be specified using a double quote character followed by the literal content
                    followed by another double quote. And regular expressions may be specified by
                    enclosing a regular expression within the forward slash ('/') character.
                </t>
                <figure anchor="primitive_strings.jcr">
                    <artwork align="center" xml:space="preserve">&primitives_strings.jcr;</artwork>
                </figure>
                <t>
                    Regular expressions are not implicitly anchored and therefore must be explicitly
                    anchored if necessary.
                </t>
                <t>
                    A string can be specified as a <xref target="RFC3986">URI</xref> using the
                    word 'uri', but also may be more narrowly scoped to a URI of a specific scheme.
                    Specific URI schemes are specified with the word 'uri' followed by two period characters
                    ('..') followed by the URI scheme.
                </t>
                <figure anchor="primitive_uris.jcr">
                    <artwork align="center" xml:space="preserve">&primitives_uris.jcr;</artwork>
                </figure>
                <t>
                    IP addresses may be specified with either the word 'ipv4' for
                    <xref target="RFC1166">IPv4 addresses</xref> or the word 'ipv6' for
                    <xref target="RFC5952">IPv6 addresses</xref>. Fully qualified A-label and
                    U-label domain names may be specified with the words 'fqdn' and 'idn'.
                </t>
                <t>
                    Dates and time can be specified as formats found in <xref target="RFC3339">RFC 3339</xref>.
                    The word 'date' corresponds to the full-date ABNF rule, the word 'time' corresponds to the
                    full-time ABNF rule, and the word 'datetime' corresponds to the 'date-time' ABNF rule.
                </t>
                <t>
                    Email addresses formatted according to <xref target="RFC5322">RFC 5322</xref> may
                    be specified using the 'email' word, and E.123 phone numbers may be specified using the
                    word 'phone'.
                </t>
                <figure anchor="primitive_misc.jcr">
                    <artwork align="center" xml:space="preserve">&primitives_misc.jcr;</artwork>
                </figure>
                <t>
                    Binary data can be specified in string form using the encodings specified in
                    <xref target="RFC4648">RFC 4648</xref>. The word 'hex' corresponds to base16, while
                    'base32', 'base32hex', 'base64', and 'base64url' correspond with their
                    RFC 4648 counterparts accordingly.
                </t>
                <figure anchor="primitive_binary.jcr">
                    <artwork align="center" xml:space="preserve">&primitives_binary.jcr;</artwork>
                </figure>
            </section>

        </section>
            <section title="Any Type">
                <t>
                    It is possible to specify that a value can be of any type allowable
                    by JSON using the word 'any'. The 'any' type specifies any primitive
                    type, array, or object.
                </t>
            </section>            
        <section title="Member Specifications">
            <t>
                Member specifications define members of JSON objects. Unlike other type specifications,
                member specifications cannot be root rules and must be part of an object specification
                or preceded by a rule name assignment.
            </t>
            <t>
                Member specifications consist of a member name specification followed by a colon character (':')
                followed by either a subordinate component, which is either a
                rule name or a primitive, object, array, or group specification. Member name specifications
                can be given either as a quoted string using double quotes or as a regular expression
                using forward slash ('/') characters. Regular expressions are not implicitly anchored
                and therefore must have explicit anchors if needed.
            </t>
            <figure anchor="member_specifications.jcr">
                <artwork xml:space="preserve" align="center">&member_specifications.jcr;</artwork>
            </figure>
        </section>
        <section title="Object Specifications">
            <t>
                Object specifications define JSON objects and are composed of zero or more
                subordinate components, each of which can be either a
                rule name, member specification, or group specification. The subordinate components
                are enclosed
                at the start with a left curly brace character ('{') and at the end with a right curly
                brace character ('}').
            </t>
            <t>
                Evaluation of the subordinate components of object specifications is as follows:
                <list style="symbols">
                    <t>
                        No order is implied for the members of the object being evaluated.
                    </t>
                    <t>
                        Subordinate components of the object specification are evaluated in
                        the order they appear.
                    </t>
                    <t>
                        Each member of the object being evaluated can only match one
                        subordinate component. 
                    </t>
                    <t>
                        Any members not matched against a subordinate component are ignored.
                    </t>
                </list>
            </t>
            <t>
                The following examples illustrate matching of JSON objects to JCR object specifications.
            </t>
            <figure anchor="object_example.jcr">
                <preamble>
                    As order is not implied for the members of objects under evaluation,
                    the following rule will match the JSON in <xref target="object_example1.json"></xref>
                    and <xref target="object_example2.json"></xref>.
                </preamble>
                <artwork align="center" xml:space="preserve">&object_example.jcr;</artwork>
            </figure>
            <figure anchor="object_example1.json">
                <artwork align="center" xml:space="preserve">&object_example1.json;</artwork>
            </figure>
            <figure anchor="object_example2.json">
                <artwork align="center" xml:space="preserve">&object_example2.json;</artwork>
            </figure>
            <figure anchor="object_order_eval.jcr">
                <preamble>
                    Because subordinate components of an object specification are evaluated in the order
                    in which they are specified (i.e. left to right, top to bottom) and object members
                    can only match one subordinate component of an object specification, the rule o1 below
                    will not match against the JSON in <xref target="object_order_eval.json"></xref> but
                    the rule o2 below will match it.
                </preamble>
                <artwork align="center" xml:space="preserve">&object_order_eval.jcr;</artwork>
                <postamble>
                    The first subordinate of rule o1 specifies that an object can have zero or more members
                    (that is the meaning of "*", see <xref target="repetition"></xref>) where the member
                    name is the letter 'p' followed by a number (e.g. "p0", "p1", "p2"), and the second
                    rule specifies a member with the exact member name of "p1". Rule o2
                    has the exact same member specifications but in the opposite order. 
                    <xref target="object_order_eval.json"></xref> does not match rule o1 because all of the
                    members match the first subordinate rule leaving none to match the second subordinate rule.
                    However, rule o2 does match because the first subordinate rule matches only one member
                    of the JSON object allowing the second subordinate rule to match the other member of
                    the JSON object.
                </postamble>
            </figure>
            <figure anchor="object_order_eval.json">
                <artwork align="center" xml:space="preserve">&object_order_eval.json;</artwork>
            </figure>
            <t>
                As stated above, members of objects which do not match a rule are ignored.
                The reason for this validation model is due to the nature of the typical
                access model to JSON objects in many programming languages, where members
                of the object are obtained by referencing the member name. Therefore
                extra members may exist without harm.
            </t>
            <t>
                However, some specifications may need to restrict the members of a JSON
                object to a known set. To construct a rule specifying that no
                extra members are expected, the @{not} annotation (see <xref target="not_annotation"></xref>)
                may be used with
                a "match-all" regular expression as the last subordinate component of the object specification.
            </t>
            <figure anchor="restrict_objects.jcr">
                <preamble>
                    The following rule will match the JSON object in <xref target="restrict_objects1.json"></xref>
                    but will not match the JSON object in <xref target="restrict_objects2.json"></xref>.
                </preamble>
                <artwork xml:space="preserve" align="center">&restrict_objects.jcr;</artwork>
            </figure>
            <figure anchor="restrict_objects1.json">
                <artwork xml:space="preserve" align="center">&restrict_objects1.json;</artwork>
            </figure>
            <figure anchor="restrict_objects2.json">
                <artwork xml:space="preserve" align="center">&restrict_objects2.json;</artwork>
            </figure>
            <t>
                This works because subordinate components are evaluated in the order they
                appear in the object rule, and the last component accepts any member with
                any type but fails to validate if one or more of those components are found
                due to the @{not} annotation.
            </t>
        </section>
        <section title="Array Specifications">
            <t>
                Array specifications define JSON arrays and are composed of zero or more subordinate
                components, each of which can either be a rule name or a primitive, array, object or
                group specification. The subordinate components are enclosed at the start with a left
                square brace character ('[') and at the end with a right square brace character (']').
            </t>
            <t>
                Evaluation of the subordinate components of array specifications is as follows:
                <list style="symbols">
                    <t>
                        The order of array items is implied unless the @{unordered} annotation is present.
                    </t>
                    <t>
                        Subordinate components of the array specification are evaluated in
                        the order they appear.
                    </t>
                    <t>
                        Each item of the array being evaluated can only match one
                        subordinate component of the array specification. 
                    </t>
                    <t>
                        If any items of the array are not matched, then the array does not match
                        the array specification.
                    </t>
                </list>
                These rules are further explained in the examples below.
            </t>
            <figure anchor="array_example.jcr">
                <artwork align="center" xml:space="preserve">&array_example.jcr;</artwork>
            </figure>
            <t>
                Unlike object specifications, order is implied in array specifications by default.
                That is, the first subordinate component will match the first element of the array, 
                the second subordinate component will match the second element of the array, and so on.
            </t>
            <t>
                Take for example the following ruleset:
            </t>
            <figure anchor="array_order_eval.jcr">
                <artwork align="center" xml:space="preserve">&array_order_eval.jcr;</artwork>
            </figure>
            <t>
                It defines two rules, a1 and a2. The array in the following JSON will not match a1, but
                will match a2.
            </t>
            <figure anchor="array_order_eval.json">
                <artwork align="center" xml:space="preserve">&array_order_eval.json;</artwork>
            </figure>
            <t>
                If an array has more elements than can be matched from the array specification,
                the array does not match the array specification. Or stated differently, an array with unmatched
                elements does not validate. Using the example array rule a2 from above, the following
                array does not match because the last element of the array does not match any subordinate
                component:
            </t>
            <figure anchor="array_order_eval2.json">
                <artwork align="center" xml:space="preserve">&array_order_eval2.json;</artwork>
            </figure>
                <t>
                    To allow an array to contain
                    any value after guaranteeing that it contains the necessary items,
                    the last subordinate component of the array specification should accept any
                    item:
                </t>
                <figure anchor="unrestricted_arrays.jcr">
                    <artwork xml:space="preserve" align="center">&unrestricted_arrays.jcr;</artwork>
                    <postamble>
                        The JSON array in <xref target="array_order_eval2.json"></xref> will validate
                        against the a3 rule in this example.
                    </postamble>
                </figure>
            
            <section title="Unordered Array Specifications" anchor="unordered_array_specifications">
                <t>
                    Array specifications can be made to behave in a similar fashion to object specifications
                    with regard to the order of matching with the @{unordered} annotation.
                </t>
                <t>
                    In the ruleset below, a1 and a2 have the same subordinate components given in the
                    same order. a2 is annotated with the @{unordered} annotation.
                </t>
                <figure anchor="array_unordered_eval.jcr">
                    <artwork align="center" xml:space="preserve">&array_unordered_eval.jcr;</artwork>
                </figure>
                <t>
                    The JSON array below does not match a1 but does match a2.
                </t>
                <figure anchor="array_order_eval.json_2">
                    <artwork align="center" xml:space="preserve">&array_order_eval.json;</artwork>
                </figure>
                <t>
                    Like ordered array specifications, the subordinate components in an unordered array specification
                    are evaluated in the order they are specified. The difference is that they
                    need not match an element of the array in the same position as given in the
                    array specification.
                </t>
                <t>
                    Finally, like ordered array specifications, unordered array specifications also require that all elements of the array be
                    matched by a subordinate component. If the array has more elements than can be
                    matched, the array does not match the array specification.
                </t>
            </section>
        </section>
        <section title="Group Specifications" anchor="group_specifications">
            <t>
                Unlike the other type specifications, group specifications have no direct tie with JSON syntax.
                Group specifications simply group together their subordinate components. Group specifications
                enclose one or more subordinate components with the parenthesis characters.
            </t>
            <t>
                Group specifications and any nesting of group specifications, must conform
                to the allowable set of type specifications of the type specifications in which
                they are contained. For example, a group specification
                inside of an array specification may not contain a member specification since member specifications are not
                allowed as direct subordinates of array specifications (arrays contain values, not object members in JSON). 
                Likewise, a group specification referenced inside an object
                specification must only contain member specifications (JSON objects may only contain object members).
            </t>
            <t>
                The following is an example of a group specification:
            </t>
            <figure anchor="group_example.jcr">
                <artwork xml:space="preserve" align="center">&group_example.jcr;</artwork>
            </figure>    
            <t>
                Like the subordinate components of array and object specifications, the subordinate components of
                a group specification are evaluated in the order they appear.
            </t>
        </section>
            <section title="Ordered and Unordered Groups in Arrays">
                <t>
                    <xref target="unordered_array_specifications"></xref> specifies that arrays can be evaluated
                    by the order of the items in the array or can be evaluated without order.
                    <xref target="group_specifications"></xref> specifies that arrays may have group rules
                    as subordinate components.
                </t>
                <t>
                    The evaluation of a group specification inside an array specification inherits the ordering property
                    of the array specification. If the array specification is unordered, then the items of the group specification
                    are also considered to be unordered. And if the array specification is ordered, then the items
                    of the group specification are also considered to be ordered.
                </t>
            </section>
            <section title="Sequence and Choice Combinations in Array, Object, and Group Specifications">
                <t>
                    Combinations of subordinate components in array, object, and group specifications can be specified as either
                    a sequence ("and") or a choice ("or"). A sequence is a subordinate component followed by the comma character
                    (',') followed by another subordinate component.
                    A choice is a subordinate component followed by a pipe character ('|') followed by another subordinate component.
                </t>
                <figure anchor="and_or_example.jcr">
                    <artwork align="center" xml:space="preserve">&and_or_example.jcr;</artwork>
                </figure>
                <t>
                    Sequence and choice combinations cannot be mixed, and group specifications must be used to
                    explicitly declare precedence between a sequence and a choice. Therefore, the following
                    is illegal:
                </t>
                <figure anchor="mixed_and_or_bad.jcr">
                    <artwork xml:space="preserve" align="center">&mixed_and_or_bad.jcr;</artwork>
                </figure>
                <t>
                    The example above should be expressed as:
                </t>
                <figure anchor="mixed_and_or_good.jcr">
                    <artwork xml:space="preserve" align="center">&mixed_and_or_good.jcr;</artwork>
                </figure>
                <t>
                    <list style="none">
                        <t>
                            NOTE: A future specification will clarify the choice ('|') operation as inclusive or,
                            exclusive or ("xor") or otherwise. At present readers should assume the choice
                            ('|') operator is an inclusive or. However, for objects and unordered arrays
                            that is not ideal, nor is xor. We are in the process of defining an algorithm
                            to "rewrite" choices of rules for use with inclusive or which is more suitable
                            for the data model of JSON.
                        </t>
                    </list>
                </t>
            </section>
            <section title="Repetition in Array, Object, and Group Specifications" anchor="repetition">
                <t>
                    Evaluation of subordinate components in array, object, and group specifications may be succeeded by
                    a repetition expression denoting how many times the subordinate component should be
                    evaluated. 
                    Repetition expressions are specified using a Kleene symbol ('?', '+', or '*') or with
                    the '*' symbol succeeded by specific minimum and/or maximum values, each being non-negative integers. Repetition expressions
                    may also be appended with a step expression, which is the '%' symbol followed by a positive integer.
                </t>
                <t>
                    When no repetition expression is present, both the minimum and maximum
                    are 1.
                </t>
                <t>
                    A minimum and maximum can be expressed by giving the minimum followed by two period characters
                    ('..') followed by the maximum, with either the minimum or maximum being optional. When the
                    minimum is not explicitly specified, it is assumed to be zero. When the maximum is not explicitly
                    specified, it is assumed to be positive infinity.
                </t>
                <figure anchor="repetition_min_max.jcr">
                    <artwork xml:space="preserve" align="center">&repetition_min_max.jcr;</artwork>
                </figure>
                <t>
                    The allowable Kleene operators are the question mark character ('?') which
                    specifies zero or one (i.e. optional), the plus character ('+') which specifies
                    one or more, and the asterisk character ('*') which specifies zero or more.
                </t>
                <figure anchor="repetition_kleene.jcr">
                    <artwork xml:space="preserve" align="center">&repetition_kleene.jcr;</artwork>
                </figure>
                <t>
                    A repetition step expression may follow a minimum to maximum expression or the
                    zero or more Kleene operator or the one or more Kleene operator. 
                    <list style="symbols">
                        <t>
                            When the repetition step
                            follows a minimum to maximum expression or the zero or more Kleene operator ('*'), it
                            specifies that the total number of repetitions present in the JSON instance
                            being validated minus the minimum repetition value
                            must be a multiple of the repetition step
                            (e.g. the total repetitions minus the minimum repetition value must be 
                            divisible by the step value with a remainder of zero).
                        </t>
                        <t>
                            When the repetition step follows 
                            a one or more Kleene operator ('+'), the minimum repetition value is set equal to the 
                            repetition step value and the total number of repetitions minus the step value must 
                            be a multiple of the repetition step value.
                        </t>
                    </list>
                     
                </t>
                <figure anchor="repetition_step.jcr">
                    <preamble>The following is an example for repetition steps in repetition expressions.</preamble>
                    <artwork xml:space="preserve" align="center">&repetition_step.jcr;</artwork>
                </figure>
            </section>
            <section title="Negating Evaluation" anchor="not_annotation">
                <t>
                    The evaluation of a rule can be changed with the @{not} annotation. With this annotation,
                    a rule that would otherwise match does not, and a rule that would not have matched does.
                    <figure anchor="not_annotation.jcr">
                        <artwork xml:space="preserve" align="center">&not_annotation.jcr;</artwork>
                    </figure>         
                </t>
            </section>
        </section>
        <section title="Directives">
            <t>
                Directives modify the processing of a ruleset. There are two forms of the directive, the 
                single line directive and the multi-line directive.
            </t>
            <t>
                Single line directives appear on their own line in a ruleset, begin
                with a hash character ('#') and are terminated by the end of the line.
                They take the following form:
            </t>
            <figure anchor="single_line_directive_example.jcr">
                <artwork xml:space="preserve" align="center">&single_line_directive_example.jcr;</artwork>
            </figure>      
            <t>
                Multi-line directives also appear on their own lines, but may span multiple lines.
                They begin with the character sequence "#{" and end with "}". The take the
                following form:
            </t>
            <figure anchor="multi_line_directive_example.jcr">
                <artwork xml:space="preserve" align="center">&multi_line_directive_example.jcr;</artwork>
            </figure>
            <t>
                This specification defines the directives "jcr-version", "ruleset-id",
                and "import", but other directives may be defined.
            </t>
            <section title="jcr-version">
                <!-- We'll obviously have to revisit this section upon publication.-->
                <t>
                    This directive declares that the ruleset complies with a specific version of this
                    standard. The version is expressed as a major integer followed by a period followed
                    by a minor integer.
                </t>            
                <figure anchor="jcr_version_current.jcr">
                    <artwork xml:space="preserve" align="center">&jcr_version_current.jcr;</artwork>
                </figure>
                <t>
                    The major.minor number signifying compliance with this document is "0.7". Upon publication
                    of this specification as an IETF proposed standard, it will be "1.0".
                    
                    <cref>
                        NOTE: This will be removed in the final version.
                    </cref>
                </t>
                <!-- This will be put into a file when the jcr validator actually accepts 1.0. Right now it accepts
                 the working version number. -->
                <figure anchor="jcr_version_final.jcr">
                    <artwork xml:space="preserve" align="center">
# jcr-version 1.0
                </artwork>
                </figure>
                <t>
                    Ruleset authors are advised to place this directive as the first line of a ruleset.
                </t>
                <t>
                    This directive may have optional extension identifiers following the version number.
                    Each extension identifiers is preceded by the plus ('+') character and separated by white space.
                    The format of extension identifiers is specific to the extension, 
                    but it is recommended that they are terminated by a version number.
                </t>
                <!-- This will be put into a file when the jcr validator actually accepts 1.0. Right now it accepts
                 the working version number. -->
                <figure anchor="jcr_version_extensions.jcr">
                    <artwork xml:space="preserve" align="center">
# jcr-version 1.0 +co-constraints-1.2 +jcr-doc-1.0
                </artwork>
                </figure>
            </section>
            <section title="ruleset-id">
                <t>
                    This directive identifies a ruleset to rule processors. It takes the form:
                </t>
                <figure anchor="ruleset_id.jcr">
                    <artwork xml:space="preserve" align="center">&ruleset_id.jcr;</artwork>
                </figure>
                <t>
					An identifier can be a URL (e.g. http://example.com/foo), an inverted domain name
					(e.g. com.example.foo) or any other form that conforms to the JCR ABNF syntax that
					a ruleset author deems appropriate.  To a JCR processor the identifier is treated as
					an opaque, case-sensitive string.
				</t>
            </section>            
            <section title="import">
                <t>
                    The import directive specifies that another ruleset is to have its rules
                    evaluated in addition to the ruleset where the directive appears.
                </t>
                <t>
                    The following is an example:
                </t>
                <!-- We don't have control of example.com, so this can't be put in as a test.-->
                <figure anchor="import_directive.jcr">
                    <artwork xml:space="preserve" align="center">
# import http://example.com/rfc9999 as rfc9999
                </artwork>
                </figure>
                <t>
                    The rule names of the ruleset to be imported may be referenced by prepending
                    the alias followed by a period character ('.') followed by the rule name
                    (i.e. "alias.name"). To continue the example above, if the ruleset at http://example.com/rfc9999
                    were to have a rule named 'encoding', rules in the ruleset importing it can
                    refer to that rule as 'rfc9999.encoding'.
                </t>
            </section>
        </section>
        <section title="Tips and Tricks">
            <section title="Any Member with Any Value">                
                <t>
                    Because member names may be specified with regular expressions, it is
                    possible to construct a member rule that matches any member name.
                    As an example, the following defines an object with a member with any name
                    that has a value that is a string:
                </t>
                <figure anchor="any_member.jcr">
                    <artwork xml:space="preserve" align="center">&any_member.jcr;</artwork>
                </figure>
                <t>
                    The JSON below matches the above rule.
                </t>
                <figure anchor="any_member1.json">
                    <artwork xml:space="preserve" align="center">&any_member1.json;</artwork>
                </figure>
                <t>
                    Likewise, the JSON below also matches the same rule.
                </t>
                <figure anchor="any_member2.json">
                    <artwork xml:space="preserve" align="center">&any_member2.json;</artwork>
                </figure>
                <t>
                    Constructing an object with a member of any name with any type would therefore
                    take the form:
                </t>
                <figure anchor="any_member_any_type.jcr">
                    <artwork xml:space="preserve" align="center">&any_member_any_type.jcr;</artwork>
                </figure>
                <t>
                    The above rule matches not only the two JSON objects above, but the JSON object below.
                </t>
                <figure anchor="any_member_any_type2.json">
                    <artwork xml:space="preserve" align="center">&any_member_any_type2.json;</artwork>
                </figure>
            </section>
            
            
            <section title="Lists of Values">
                <t>
                    Group specifications may be used to create enumerated lists of
                    primitive data types, because primitive specifications may
                    contain a group specification, which may have multiple primitive specifications.
                    Because a primitive specification must resolve to a single data type,
                    the group specification must only contain choice combinations.
                </t>
                <t>
                    Consider the following examples:
                </t>
                <figure anchor="lists_of_values.jcr">
                    <artwork xml:space="preserve" align="center">&lists_of_values.jcr;</artwork>
                </figure>
            </section>
            <section title="Groups in Arrays"> 
                <t>
                    Groups may be a subordinate component of array specifications:
                </t>
                <figure anchor="groups_in_arrays.jcr">
                    <artwork xml:space="preserve" align="center">&groups_in_arrays.jcr;</artwork>
                </figure>
                <t>
                    Unlike primitive specifications, subordinate group specifications in array specifications
                    may have sequence combinations and contain any type specification.
                </t>
                <figure anchor="groups_in_arrays2.jcr">
                    <artwork xml:space="preserve" align="center">&groups_in_arrays2.jcr;</artwork>
                </figure>
            </section>
            <section title="Groups in Objects">
                <t>
                    Groups may be a subordinate component of object specifications:
                    Subordinate group specifications in object specifications may have sequence
                    combinations but must only contain member specifications.
                </t>
                <figure anchor="groups_in_objects.jcr">
                    <artwork xml:space="preserve" align="center">&groups_in_objects.jcr;</artwork>
                </figure>
                <t>
                    <list style="none">
                        <t>
                            NOTE: A future specification will clarify the choice ('|') operation as inclusive or,
                            exclusive or ("xor") or otherwise. At present readers should assume the choice
                            ('|') operator is an inclusive or. We are in the process of defining an algorithm
                            to "rewrite" choices of rules for use with inclusive or which is more suitable
                            for the data model of JSON. Such a change will impact the guidance given below.
                        </t>
                    </list>
                </t>
                
                <t>
                    When using groups to use both sequences and choices of member specifications,
                    consideration must be given to the processing of object specifications where by
                    unmatched member specifications are ignored (see <xref target="member_specifications.jcr"></xref>).
                </t>
                <figure anchor="groups_in_objects_ignored1.jcr">
                    <preamble>
                        A casual reading of this rule might lead a reader to believe that the JSON object in
                        <xref target="groups_in_objects_ignored.json"></xref> would not match, however it does
                        because the extra member (either "foo" or "baz") is not matched but is ignored.
                    </preamble>
                    <artwork xml:space="preserve" align="center">&groups_in_objects_ignored1.jcr;</artwork>
                </figure>
                <figure anchor="groups_in_objects_ignored.json">
                    <artwork xml:space="preserve" align="center">&groups_in_objects_ignored.json;</artwork>
                </figure>
                <t>
                    The rule in <xref target="groups_in_objects_ignored1.jcr"></xref> must be modified
                    to either match all extra rules, as in <xref target="groups_in_objects_ignored2.jcr"></xref>,
                    or the logic of the rules must be rewritten to explicitly negate the presence of the
                    unwanted members, as in <xref target="groups_in_objects_ignored3.jcr"></xref>.
                </t>
                <figure anchor="groups_in_objects_ignored2.jcr">
                    <artwork align="center" xml:space="preserve">&groups_in_objects_ignored2.jcr;</artwork>
                </figure>
                <figure anchor="groups_in_objects_ignored3.jcr">
                    <artwork align="center" xml:space="preserve">&groups_in_objects_ignored3.jcr;</artwork>
                </figure>
            </section>
            <section title="Group Rules as Macros">
                <t>
                    The syntax for group specifications accommodates one ore more subordinate components and
                    a repetition expression for each. Other than grouping multiple rules, a
                    group specification can be used as a macro definition for a single rule.
                </t>
                <figure anchor="macro.jcr">
                    <artwork xml:space="preserve" align="center">&macro.jcr;</artwork>
                </figure> 
            </section>
            <section title="Object Mixins">
                <t>
                    Group rules can be used to create object mixins, a pattern for writing data
                    models similar in style to object derivation in some programming languages.
                    In the example in below,
                    both obj1 and obj2 have a members "foo" and "fob" with obj1 having the additional member "bar"
                    and obj2 having the additional member "baz".
                </t>
                <figure anchor="object_mixin.jcr">
                    <artwork xml:space="preserve" align="center">&object_mixin.jcr;</artwork>
                </figure>
            </section>
            <section title="Subordinate Dependencies">
                <t>
                    In object and array specifications, there may be situations in which it is necessary to
                    condition the existence of a subordinate component on the existence of a sibling subordinate
                    component. In other words, example_two should only be evaluated if example_one
                    evaluates positively. Or put another way, a member of an object or an item of an
                    array may be present only on the condition that another member or item is present.
                </t>
                <t>
                    In the following example, the referrer_uri member can only be present if the
                    location_uri member is present.
                </t>
                <figure anchor="subordinate_dependents.jcr">
                    <artwork xml:space="preserve" align="center">&subordinate_dependents.jcr;</artwork>
                </figure>
            </section>
        </section>
        <section title="Implementation Status" anchor="implementation_status">
            <t>
                This section records the status of known implementations of the
                protocol defined by this specification at the time of posting of
                this Internet-Draft, and is based on a proposal described in
                <xref target="RFC7492"></xref> .  The description of implementations in this section is
                intended to assist the IETF in its decision processes in
                progressing drafts to RFCs.  Please note that the listing of any
                individual implementation here does not imply endorsement by the
                IETF.  Furthermore, no effort has been spent to verify the
                information presented here that was supplied by IETF contributors.
                This is not intended as, and must not be construed to be, a
                catalog of available implementations or their features.  Readers
                are advised to note that other implementations may exist.
            </t>
            <t>
                According to <xref target="RFC7492"></xref> , "this will allow reviewers and working
                groups to assign due consideration to documents that have the
                benefit of running code, which may serve as evidence of valuable
                experimentation and feedback that have made the implemented
                protocols more mature.  It is up to the individual working groups
                to use this information as they see fit".
            </t>
            <section title="JCR Validator" anchor="jcr_validator">
                <t>
                    The JCR Validator, written in Ruby, currently implements all portions of this
                    specification, and has been used extensively to prototype various aspects of JCR under
                    consideration. It's development has gone hand-in-hand with this specification.
                </t>
                <t>
                    This software is primarily produced by the American Registry for Internet Numbers (ARIN)
                    and freely distributable under the ISC license.
                </t>
                <t>
                    Source code for this software is available on GitHub at
                    <eref target="https://github.com/arineng/jcrvalidator"></eref>. This software is also easily
                    obtained as a Ruby Gem through the Ruby Gem system.
                </t>
            </section>
            <section title="Codalogic JCR Parser" anchor="codalogic_jcr_parser">
                <t>
                    The Codalogic JCR Parser is a C++ implementation of a JCR parsing engine, and is a work
                    in progress. It is targeted for the Windows platform.
                </t>
                <t>
                    This software is produced by Codalogic Ltd and freely distributable under the Gnu LGPL v3
                    license.
                </t>
                <t>
                    Source code is availabe on GitHub at
                    <eref target="https://github.com/codalogic/cl-jcr-parser"></eref>.
                </t>
            </section>
            <section title="JCR Java" anchor="jcr_java">
                <t>
                    JCR Java is a work in progress and currently only implements the parsing of JCR rulesets
                    according to the ABNF using a custom parsing framework.
                </t>
                <t>
                    This software is produced by the American Registry for Internet Numbers (ARIN)
                    and freely distributable under the MIT license.
                </t>
                <t>
                    Source code is available on BitBucket at
                    <eref target="https://bitbucket.org/anewton_1998/jcr_java"></eref>.
                </t>
            </section>
        </section>
        <section title="ABNF Syntax">
            <figure title="ABNF for JSON Content Rules" anchor="abnf">
                <preamble>
                    The following ABNF describes the syntax for JSON Content Rules.
                    A text file containing these ABNF rules can be downloaded from
                    <xref target="JCR_ABNF"></xref>.
                </preamble>
                <artwork xml:space="preserve">&ABNF;</artwork>
            </figure>
        </section>        
        <section title="Acknowledgements">
            <t>
                John Cowan, Andrew Biggs, Paul Kyzivat and Paul Jones provided feedback and suggestions
                which led to many changes in the syntax.
            </t>
        </section>
    </middle>
    <back>
        <references title="Normative References">
            
            &RFC1166;
            &RFC3339;
            &RFC3986;
            &RFC4234;
            &RFC4648;
            &RFC5322;
            &RFC5952;
            &RFC8259;
            
            
            
            <reference anchor="JCR_ABNF"
                target="https://raw.githubusercontent.com/arineng/jcr/master/jcr-abnf.txt">
                <front>
                    <title>ABNF for JSON Content Rules</title>
                    <author fullname="Andrew Lee Newton" initials="A.L." surname="Newton">
                        <organization abbrev="ARIN">American Registry for Internet
                            Numbers</organization>
                        <address>
                        <postal>
                            <street>3635 Concorde Parkway</street>
                            <city>Chantilly</city>
                            <region>VA</region>
                            <country>US</country>
                            <code>20151</code>
                        </postal>
                        <email>andy@arin.net</email>
                        <uri>http://www.arin.net</uri>
                        </address>
                    </author>
                    <author fullname="Pete Cordell" initials="P." surname="Cordell">
                        <organization>Codalogic</organization>
                        <address>
                            <postal>
                            <street>PO Box 30</street>
                            <city>Ipswich</city>
                            <country>UK</country>
                            <code>IP5 2WY</code>
                            </postal>
                            <email>pete.cordell@codalogic.com</email>
                            <uri>http://www.codalogic.com</uri>
                        </address>
                    </author>
                    <date/>
                </front>
            </reference>
            
        </references>
        <references title="Infomative References">
            
            &I-D.cordell-jcr-co-constraints;
            &RFC7492;
        </references>
        <section title="Experimental Features">
            <t>
                The following features are in development and may appear in a future version
                of this specification.
            </t>
            <section title="Augmented OR of Objects">
                <t>
                    Augmented OR of objects is an algorithm for better writing of OR, where the
                    current approach uses simple inclusive OR. The design goal behind augmented OR
                    is to give the writer and the reader a "that's what I meant" solution.
                </t>
                <figure anchor="augmented_or_jcr">
                    <preamble>
                        For example, take the following rule for an object where two members are
                        given as a choice.
                    </preamble>
                    <artwork xml:space="preserve" align="center">
{ "foo":string | "bar":integer }
                    </artwork>
                </figure>
                <t>
                    The interpretation of <xref target="augmented_or_jcr"/> is that the object may either
                    contain a member named "foo" that is a string or a member named "bar" that is an
                    integer. To some, that raises a number of questions:
                    <list>
                        <t>May the object contain both "foo" and "bar"?</t>
                        <t>May the object contain "foo" as a string and "bar" as anything other than an integer?</t>
                    </list>
                </t>
                <figure anchor="ior_rewritten_jcr">
                    <preamble>
                        With normal inclusive OR, it might be necessary to write more complicated rules to
                        disambiguate the desired contents of the object, as this rule demonstrates.
                    </preamble>
                    <artwork xml:space="preserve" align="center">
{
  ( "foo":string , @{not} "bar":any ) |
  ( "bar":integer, @{not} "foo":any )
}
                    </artwork>
                </figure>
                <t>
                    The augmented OR algorithm for objects would allow <xref target="augmented_or_jcr"></xref>
                    to mean the equivalent as the <xref target="ior_rewritten_jcr"></xref> using inclusive OR.
                </t>
            </section>
            <section title="New Data Types">
                <t>
                    JCR is intentionally designed with a rich set of data types to eas the burden of reading
                    and writing rules.
                </t>
                <t>
                    The following are a list of new data types under consideration:
                    <list>
                        <t>
                            JCR currently has 'ipaddr', 'ipv4', and 'ipv6' data types, but often
                            groups of IP addresses are specified using CIDR notation. 'cidr', 'cidr4',
                            'cidr6' are under consideration to cover these data types.
                        </t>
                        <t>
                            The 'any' type covers all value type specifications: objects, arrays, and
                            primitives. There may be cases where narrowing to a specific value type is
                            desired, so 'anyobject', 'anyarray', and 'anyprimitive' are under consideration.
                        </t>
                    </list>
                </t>
            </section>
            <section title="New Annotations">
                <t>
                    JCR can be extended through the use of annotation but also has a set of standard
                    annotations. The design philosophy for annotations are to provide features to the
                    language that are not as common or do not have a clear, less-wordy syntax.
                </t>
                <t>
                    The following annotations are under consideration:
                    <list>
                        <t>
                            A '@{default ...}' annotation has been proposed to help the reader understand
                            there may be a default value if one is not given. This annotation does not provide
                            much value for validation and is intended as a reading aid to provide semantic
                            information.
                        </t>
                        <t>
                            Both '@{minExclusive ...}' and '@{maxExclusive ...}' annotations have been proposed
                            to avoid adding extra arcane syntax for excluding the boundaries of numeric ranges.
                        </t>
                        <t>
                            A '@{augments RULENAME}' or '@{extends RULENAME}' annotation has been discussed to
                            provide a better extension mechanism of rules.
                        </t>
                    </list>
                </t>
            </section>
        </section>
        <section title="Co-Constraints">
            <t>
                This specification defines a small set of annotations and directives for JCR, yet
                the syntax is extensible allowing for other annotations and directives.
                <xref target="I-D.cordell-jcr-co-constraints"></xref> ("Co-Constraints for JCR") defines further
                annotations and directives which define more detailed constraints on JSON
                messages, including co-constraints (constraining parts of JSON message based
                on another part of a JSON message).
            </t>
        </section>
        <section title="Testing Against JSON Content Rules">
            <t>
                One aspect of JCR that differentiates it from other format schema languages are
                the mechanisms helpful to developers for taking a formal specification, such as
                that found in an RFC, and evolving it into unit tests, which are essential to
                producing quality protocol implementations.
            </t>
            <section title="Locally Overriding Rules">
                <t>
                    As mentioned in the introduction, one tool for testing would be the
                    ability to locally override named rules. As an example, consider the
                    following rule which defines an array of strings.
                </t>
                <figure anchor="override1.jcr">
                    <artwork xml:space="preserve" align="center">&override1.jcr;</artwork>
                </figure>
                <t>
                    Consider the specification where this rule is found does not define the
                    values but references an extensible list of possible values updated
                    independently of the specification, such as in an IANA registry.
                </t>
                <t>
                    If a software developer desired to test a specific situation in which the
                    array must at least contain the status "accepted", the rules from the specification
                    could be used and the statuses rule could be explicitly overridden locally as:
                </t>
                <figure anchor="override2.jcr">
                    <preamble>
                        This rule will evaluate positively with the JSON in <xref target="override1.json"></xref>
                    </preamble>
                    <artwork xml:space="preserve" align="center">&override2.jcr;</artwork>
                </figure>
                <figure anchor="override1.json">
                    <artwork xml:space="preserve" align="center">&override1.json;</artwork>
                </figure>
                <t>
                    Alternatively, the developer may need to ensure that the status "denied" should
                    not be present in the array:
                </t>
                <figure anchor="override3.jcr">
                    <preamble>
                        This rule will fail to evaluate the JSON in <xref target="override2.json"></xref>
                        thus signaling a problem.
                    </preamble>
                    <artwork xml:space="preserve" align="center">&override3.jcr;</artwork>
                </figure>
                <figure anchor="override2.json">
                    <artwork xml:space="preserve" align="center">&override2.json;</artwork>
                </figure>
            </section>
            <section title="Rule Callbacks">
                <t>
                    In many testing scenarios, the evaluation of rules may become more complex
                    than that which can be expressed in JCR, sometimes involving variables and
                    interdependencies which can only be expressed in a programming language.
                </t>
                <t>
                    A JCR processor may provide a mechanism for the execution of local functions
                    or methods based on the name of a rule being evaluated. Such a mechanism
                    could pass to the function the data to be evaluated, and that function could
                    return to the processor the result of evaluating the data in the function.
                </t>
            </section>
        </section>
        <section title="Changes from -09 and -10" anchor="changes">
            <t>
                The syntax of JCR was changed so that rule name assignments to primitive types
                no longer requires the '=:' syntax. The '=:' is still provided for backwards
                compatibility. Other syntax changes have been made to accommodate the syntax
                of future annotations.
            </t>
        </section>
    </back>
</rfc>
