<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE rfc SYSTEM "http://xml.resource.org/authoring/rfc2629.dtd"
[
  <!ENTITY RFC1166 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.1166.xml'>
  <!ENTITY RFC3339 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3339.xml'>
  <!ENTITY RFC3986 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.3986.xml'>
  <!ENTITY RFC4234 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4234.xml'>
  <!ENTITY RFC4627 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4627.xml'>
  <!ENTITY RFC4648 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.4648.xml'>
  <!ENTITY RFC5322 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5322.xml'>
  <!ENTITY RFC5952 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.5952.xml'>
  <!ENTITY RFC6570 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.6570.xml'>
  <!ENTITY RFC7159 PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml/reference.RFC.7159.xml'>
  <!ENTITY I-D.cordell-jcr-co-constraints PUBLIC ''
   'http://xml.resource.org/public/rfc/bibxml3/reference.I-D.cordell-jcr-co-constraints.xml'>
   
  <!ENTITY ABNF PUBLIC ''
    'jcr-abnf.txt'>
  <!ENTITY first_example.json PUBLIC ''
    'figs/first_example.json'>
  <!ENTITY first_example.jcr PUBLIC ''
    'figs/first_example.jcr'>
  <!ENTITY first_example2.jcr PUBLIC ''
    'figs/first_example2.jcr'>   
  <!ENTITY second_example.json PUBLIC ''
    'figs/second_example.json'>   
  <!ENTITY second_example.jcr PUBLIC ''
    'figs/second_example.jcr'>   
  <!ENTITY second_example2.jcr PUBLIC ''
    'figs/second_example2.jcr'>   
  <!ENTITY second_example_override.jcr PUBLIC ''
    'figs/second_example_override.jcr'>   
  <!ENTITY rfc4627_example.json PUBLIC ''
    'figs/rfc4627_example.json'>   
  <!ENTITY rfc4627_example.jcr PUBLIC ''
    'figs/rfc4627_example.jcr'>   
  <!ENTITY rfc4627_example2.jcr PUBLIC ''
    'figs/rfc4627_example2.jcr'>   
  <!ENTITY rule_name_ruleset_id.jcr PUBLIC ''
    'figs/rule_name_ruleset_id.jcr'>
  <!ENTITY assignment_example.jcr PUBLIC ''
    'figs/assignment_example.jcr'>
  <!ENTITY annotation_example.jcr PUBLIC ''
    'figs/annotation_example.jcr'>
  <!ENTITY primitives_overview.jcr PUBLIC ''
    'figs/primitives_overview.jcr'>
  <!ENTITY primitives_boolean_and_null.jcr PUBLIC ''
    'figs/primitives_boolean_and_null.jcr'>
  <!ENTITY primitives_integer_and_float.jcr PUBLIC ''
    'figs/primitives_integer_and_float.jcr'>
  <!ENTITY primitives_float_range.jcr PUBLIC ''
    'figs/primitives_float_range.jcr'>
  <!ENTITY primitives_bit_integers.jcr PUBLIC ''
    'figs/primitives_bit_integers.jcr'>
  <!ENTITY primitives_strings.jcr PUBLIC ''
    'figs/primitives_strings.jcr'>
  <!ENTITY primitives_uris.jcr PUBLIC ''
    'figs/primitives_uris.jcr'>
  <!ENTITY primitives_misc.jcr PUBLIC ''
    'figs/primitives_misc.jcr'>
  <!ENTITY primitives_binary.jcr PUBLIC ''
    'figs/primitives_binary.jcr'>
  <!ENTITY member_specifications.jcr PUBLIC ''
    'figs/member_specifications.jcr'>
  <!ENTITY object_example.jcr PUBLIC ''
    'figs/object_example.jcr'>
  <!ENTITY object_example1.json PUBLIC ''
    'figs/object_example1.json'>
  <!ENTITY object_example2.json PUBLIC ''
    'figs/object_example2.json'>
  <!ENTITY object_order_eval.json PUBLIC ''
    'figs/object_order_eval.json'>
  <!ENTITY object_order_eval.jcr PUBLIC ''
    'figs/object_order_eval.jcr'>
  <!ENTITY array_example.jcr PUBLIC ''
    'figs/array_example.jcr'>
  <!ENTITY array_order_eval.jcr PUBLIC ''
    'figs/array_order_eval.jcr'>
  <!ENTITY array_order_eval.json PUBLIC ''
    'figs/array_order_eval.json'>
  <!ENTITY array_order_eval2.json PUBLIC ''
    'figs/array_order_eval2.json'>
  <!ENTITY array_unordered_eval.jcr PUBLIC ''
    'figs/array_unordered_eval.jcr'>
  <!ENTITY group_example.jcr PUBLIC ''
    'figs/group_example.jcr'>
  <!ENTITY and_or_example.jcr PUBLIC ''
    'figs/and_or_example.jcr'>
  <!ENTITY mixed_and_or_bad.jcr PUBLIC ''
    'figs/mixed_and_or_bad.jcr'>
  <!ENTITY mixed_and_or_good.jcr PUBLIC ''
    'figs/mixed_and_or_good.jcr'>

]>
<?rfc toc="yes"?>
<rfc category="std" docName="draft-newton-json-content-rules-07" ipr="trust200902">
    <front>
        <title abbrev="JSON Content Rules">A Language for Rules Describing JSON Content</title>
        <author fullname="Andrew Lee Newton" initials="A.L." surname="Newton">
            <organization abbrev="ARIN">American Registry for Internet Numbers</organization>
            <address>
                <postal>
                    <street>3635 Concorde Parkway</street>
                    <city>Chantilly</city>
                    <region>VA</region>
                    <country>US</country>
                    <code>20151</code>
                </postal>
                <email>andy@arin.net</email>
                <uri>http://www.arin.net</uri>
            </address>
        </author>
        <author fullname="Pete Cordell" initials="P." surname="Cordell">
            <organization>Codalogic</organization>
            <address>
                <postal>
                    <street>PO Box 30</street>
                    <city>Ipswich</city>
                    <country>UK</country>
                    <code>IP5 2WY</code>
                </postal>
                <email>pete.cordell@codalogic.com</email>
                <uri>http://www.codalogic.com</uri>
            </address>
        </author>
        <date/>
        <abstract>
            <t>
                This document describes a language for specifying and testing the expected content of JSON structures
                found in JSON-using protocols, software, and processes.
            </t>
        </abstract>
    </front>
    <middle>
        <section title="Introduction">
            <t>
                This document describes JSON Content Rules (JCR), a language
                for specifying and testing the interchange of data
                in <xref target="RFC7159">JSON</xref> format used by computer protocols and processes.
                The syntax of JCR is not JSON but is "JSON-like", possessing the conciseness and
                utility that has made JSON popular.
            </t>
            <section title="A First Example: Specifying Content">
                <t>
                    The following JSON data describes a JSON object with two members, "line-count" and
                    "word-count", each containing an integer.                    
                </t>
                <figure>
                    <artwork xml:space="preserve" align="center">&first_example.json;</artwork>
                </figure>
                <t>
                    This is also JCR that describes a JSON object with a member named "line-count" that is
                    an integer that is exactly 3426 and a member named "word-count" that is an integer that
                    is exactly 27886.
                </t>
                <t>
                    For a protocol specification, it is probably more useful to specify that each member
                    is any integer and not specific, exact integers:
                </t>
                <figure>
                    <artwork xml:space="preserve" align="center">&first_example.jcr;</artwork>
                </figure>
                <t>
                    Since line counts and word counts should be either zero or a positive integer,
                    the specification may be further narrowed:
                </t>                
                <figure>
                    <artwork xml:space="preserve" align="center">&first_example2.jcr;</artwork>
                </figure>
            </section>
            <section title="A Second Example: Testing Content">
                <t>
                    Building on the first example, this second example describes the same object
                    but with the addition of another member, "file-name".
                </t>
                <figure>
                    <artwork xml:space="preserve" align="center">&second_example.json;</artwork>
                </figure>                
                <t>
                    The following JCR describes objects like it.
                </t>
                <figure>
                    <artwork xml:space="preserve" align="center">&second_example.jcr;</artwork>
                </figure>                
                <t>
                    For the purposes of writing a protocol specification, JCR may be broken down into
                    named rules to reduce complexity and to enable re-use. The following example takes
                    the JCR from above and rewrites the members as named rules.
                </t>
                <figure>
                    <artwork xml:space="preserve" align="center">&second_example2.jcr;</artwork>
                </figure>                
                <t>
                    With each member specified as a named rule, software testers can override them locally
                    for specific test cases. In the following example, the named rules are locally overridden
                    for the test case where the file name is "rfc4627.txt".
                </t>                
                <figure>
                    <artwork xml:space="preserve" align="center">&second_example_override.jcr;</artwork>
                </figure>      
                <t>
                    In this example, the protocol specification describes the JSON object in general and
                    an implementation overrides the rules for testing specific cases.
                </t>
            </section>
        </section>
        <section title="Overview of the Language">
            <t>
                JCR is composed of rules (as the name suggests). A collection of rules that is processed
                together is a ruleset. Rulesets may also contain comments, blank lines, and directives
                that apply to the processing of a ruleset.
            </t>
            <t>
                Rules are composed of two parts, an optional rule name assignment and a type specification.
                Rules may be defined across line boundaries and there is no line continuation syntax. The
                type specification component of rules are a superset of JSON.
            </t>
            <t>
                Rules with rule name assignments may be referenced in the type specifications of other rules.
                And type specifications, depending on their type, may be composed of other type specifications.
                Type specifications define arrays, objects, members of objects, primitive types, and groups
                of types.
            </t>
            <t>
                Any rule consisting only of a type specification is considered a root rule. Unless otherwise
                specified, all the root rules of a ruleset are evaluated against a JSON instance or document.
            </t>
            <t>
                Putting it all together, <xref target="rfc4627-example-1-compact-rules"></xref>
                describes the JSON in <xref target="rfc4627-example-1"></xref>.
            </t>
            <figure anchor="rfc4627-example-1">
                <preamble>Example JSON shamelessly lifted from RFC 4627</preamble>
                <artwork xml:space="preserve" align="center">&rfc4627_example.json;</artwork>
            </figure>
            <figure anchor="rfc4627-example-1-compact-rules">
                <preamble>Rules describing <xref target="rfc4627-example-1"></xref></preamble>
                <artwork xml:space="preserve" align="center">&rfc4627_example2.jcr;</artwork>
            </figure>
        </section> 
        <section title="Lines and Comments">
            <t>
                There is no statement terminator and therefore no need for a line continuation syntax.
                Rules may be defined across line boundaries.
                Blank lines are allowed.
            </t>
            <t>
                Comments are very similar to comments in <xref target="RFC4234">ABNF</xref>. They start with a semi-colon (';') and
                continue to the end of the line or another semi-colon.
            </t>
        </section>
        <section title="Rules">
            <t>
                Rules have two main components, an optional rule name assignment and a type specification.
                Type specifications define arrays, objects, etc... of JSON and may reference other rules
                using rule names. Most type specifications can be defined with repetitions for specifying
                the frequency of the type being defined. In addition to the type specifications describing
                JSON types, there is an additional group specification for grouping types.
            </t>
            <t>
                Rules may also contain annotations which may affect the evaluation of all or part of a rule.
                Rules without a rule name assignment are considered root rules, though rules with a rule
                name assignment can be considered a root rule with the appropriate annotation.
            </t>
            <t>
                Type specifications, depending on their type, can contain zero or more other type
                specifications or rule names. For example, an object specification might contain multiple
                member specifications or rules names that resolve to member specifications or a mixture
                of member specifications and rule names. For the purposes of this document, type specifications
                and rule names composing other type specifications are called subordinate components.
            </t>
            <section title="Rule Names and Assignments">
                <t>
                    Rule names are signified with the dollar character ('$'), which is not part of the
                    rule name itself. Rule names have two components, an optional ruleset identifier and a local
                    rule name.
                </t>
                <t>
                    Local rule names must start with an alphabetic character (a-z,A-Z) and must contain only
                    alphabetic characters, numeric characters, the hyphen character ('-') and the
                    underscore character ('_'). Local rule names are case sensitive, and must be unique
                    within a ruleset (that is, no two rule name assignements may use the same local rule name).
                </t>
                <t>
                    Ruleset identifiers reference rules from another ruleset. They are not allowed in rule
                    name assignments, and only found in the directive specifying the ruleset identifier for
                    a ruleset and rule names referenced by other rules. Ruleset identifiers must start with
                    an alphabetic character and contain no whitespace. Ruleset identifiers are case sensitive.
                    Simple use cases of JCR will most likely not use ruleset identifiers.
                </t>
                <figure>
                    <artwork align="center" xml:space="preserve">&rule_name_ruleset_id.jcr;</artwork>
                </figure>
                <t>
                    There are two forms of rule name assignments: assignements of primitive types and assignments
                    of all other types. Rule name assignments to primitive type specifications separate the rule
                    name from the type specification with the character sequence '=:', whereas rule name assignments
                    for all other type specifications only require the separation using the '=' character.
                </t>
                <figure>
                    <artwork xml:space="preserve" align="center">&assignment_example.jcr;</artwork>
                </figure>
                <t>
                    This is the one little "gotcha" in JCR. This syntax is necessary so that JCR parsers may
                    distinguish between rules name assignments involving primitives and object member type
                    specifications involving primitives.
                </t>
            </section>
            <section title="Annotations">
                <t>
                    Annotations may appear before a rule name assignment, before a type specification, or
                    before a rule name contained within a type specification. In each place, there may be
                    zero or more annotations.
                    Each annotation begins with the
                    character sequence "@{" and ends with "}". The following is an example of a type specification
                    with the not annotation (explained in <xref target="not_annotation"></xref>):
                </t>
                <figure>
                    <artwork xml:space="preserve" align="center">&annotation_example.jcr;</artwork>
                </figure>
                <t>
                    This specification defines the annotations "root", "not", and "unordered", but
                    other annotations may be defined for other purposes.
                </t>
            </section>
            <section title="Starting Points and Root Rules" anchor="starting-points">
                <t>
                    Evaluation of a JSON instance or document against a ruleset begins with the evaluation of
                    a root rule or set of root rules. If no root rule (or rules) is specified locally at
                    runtime, the set of root rules specified in the ruleset are evaluated. The order of
                    evaluation is undefined.
                </t>
                <t>
                    The set of root rules specified in a ruleset is composed of all rules without a rule
                    name assignment and all rules annotated with the "@{root}" annotation.
                </t>
                <t>
                    The "@{root}" annotation may either appear before a rule name assignment or before
                    a type definition. It is ignored if present before referenced rule name inside of a
                    type specification.
                </t>
            </section>
            <section title="Type Specifications">
                <t>
                    The syntax of each type of type specifications varies depending on the type:
                </t>
                <figure>
                    <artwork xml:space="preserve" align="center">&primitives_overview.jcr;</artwork>
                </figure>
            </section>
            <section title="Primitive Specifications">
            <t>
                Primitive type specifications define content for JSON numbers, booleans, strings, and null.
            </t>
            <section title="Numbers, Booleans and Null">
            <t>
                The rules for booleans and null are the simplest and take the following forms:
            </t>
            <figure>
                <artwork xml:space="preserve" align="center">&primitives_boolean_and_null.jcr;</artwork>
            </figure>
                <t>
                Rules for numbers can specify the number be either an integer or floating point number:
                </t>
                <figure>
                    <artwork xml:space="preserve" align="center">&primitives_integer_and_float.jcr;</artwork>
                </figure>
                <t>
                Numbers may also be specified as an absolute value or a range of possible values, where a range
                may be specified using a minimum, maximum, or both:
                </t>
                <figure>
                    <artwork align="center" xml:space="preserve">
  n
  n..m
   ..m
  n..
n.f
n.f..m.f
   ..m.f
n.f..
                    </artwork>
                </figure>
                <t>
                When specifying a minimum and a maximum, both must either be an integer or a floating point number.
                Thus to specify a floating point number between zero and ten a definition of the following form is used:
            </t>
            <figure>
                <artwork xml:space="preserve" align="center">&primitives_float_range.jcr;</artwork>
            </figure>  
                <t>
                    Integers may also be specified as ranges using bit lengths preceded by the 'int' or 'uint'
                    words (i.e. 'int8', 'uint16'). The 'int' word specifies the integer as being signed whereas
                    the 'uint' word specifies the integer as being unsigned.
                </t>
                <figure>
                    <artwork xml:space="preserve" align="center">&primitives_bit_integers.jcr;</artwork>
                </figure>  
            </section>
            <section title="Strings">
                <t>
                    JCR provides a large number of data types to define the contents of JSON strings.
                    Generically, a string may be specified using the word 'string'. String literals
                    may be specified using a double quote character followed by the literal content
                    followed by another double quote. And regular expressions may be specified by
                    enclosing a regular expression in the forward slash ('/') character.
                </t>
                <figure>
                    <artwork align="center" xml:space="preserve">&primitives_strings.jcr;</artwork>
                </figure>
                <t>
                    A string can be specified as a <xref target="RFC3986">URI</xref> using the
                    word 'uri', but also may be more narrowly specified using a <xref target="RFC6570">URI template</xref>.
                    URI templates are specified with the word 'uri' followed by two period characters
                    ('..') followed by the URI template.
                    When using URI templates, the variable names are ignored for pattern matching,
                    but they should be provided for construction of a valid URI template. Providing
                    the variable names also aids in the description of what is to be matched.
                </t>
                <figure>
                    <artwork align="center" xml:space="preserve">&primitives_uris.jcr;</artwork>
                </figure>
                <t>
                    IP addresses may be specified with either the word 'ipv4' for
                    <xref target="RFC1166">IPv4 addresses</xref> or the word 'ipv6' for
                    <xref target="RFC5952">IPv6 addresses</xref>. Fully qualified A-label and
                    U-label domain names may be specified with the words 'fqdn' and 'idn'.
                </t>
                <t>
                    Dates and time can be specified as formats found in <xref target="RFC3339">RFC 3339</xref>.
                    The word 'date' corresponds to the full-date ABNF rule, the word 'time' corresponds to the
                    full-time ABNF rule, and the word 'datetime' corresponds to the 'date-time' ABNF rule.
                </t>
                <t>
                    Email addresses formatted according to <xref target="RFC5322">RFC 5322</xref> may
                    be specified using the 'email' word, and E.123 phone number may be specified using the
                    word 'phone'.
                </t>
                <figure>
                    <artwork align="center" xml:space="preserve">&primitives_misc.jcr;</artwork>
                </figure>
                <t>
                    Binary date can be specified in string form using the encodings specified in
                    <xref target="RFC4648">RFC 4648</xref>. The word 'hex' corresponds to base16, while
                    'base32', 'base32hex', 'base64', and 'base64url' correspond with their
                    RFC 4648 counterparts accordingly.
                </t>
                <figure>
                    <artwork align="center" xml:space="preserve">&primitives_binary.jcr;</artwork>
                </figure>
            </section>

        </section>
            <section title="Any Type">
                <t>
                    It is possible to specify that a value can be of any type allowable
                    by JSON using the word 'any'. The 'any' type specifies any primitive
                    type, array, or object.
                </t>
            </section>            
        <section title="Member Specifications">
            <t>
                Member specifications define members of JSON objects. Unlike other type specfications,
                member specifications cannot be root rules and must be part of an object specification
                or preceded by a rule name assignment.
            </t>
            <t>
                Member specifications consist of a member name specification followed by a colon character (':')
                followed by either a subordinate component, which is either a
                rule name or a primitive, object, array, or group specification. Member name specifications
                can be given either as a quated string using double quotes or as a regular expression
                using forward slash ('/') characters.
            </t>
            <figure>
                <artwork xml:space="preserve" align="center">&member_specifications.jcr;</artwork>
            </figure>
        </section>
        <section title="Object Specifications">
            <t>
                Object specifications define JSON objects and are composed of zero or more
                subordinate components, each of which can be either a
                rule name, member specification, or group specification. The subordinate components
                are enclosed
                at the start with a left curly brace character ('{') and at the end with a right curly
                brace character ('}').
            </t>
            <figure>
                <artwork align="center" xml:space="preserve">&object_example.jcr;</artwork>
            </figure>
            <t>
                The subordinate components of an object specification do not imply
                order. Given the example above, both JSON examples are valid:
            </t>
            <figure>
                <artwork align="center" xml:space="preserve">&object_example1.json;</artwork>
            </figure>
            <figure>
                <artwork align="center" xml:space="preserve">&object_example2.json;</artwork>
            </figure>
            <t>
                Subordinate components of an object specification are evaluated in the order in which
                they appear.
            </t>
            <t>
                Take for example the following ruleset:
            </t>
            <figure>
                <artwork align="center" xml:space="preserve">&object_order_eval.jcr;</artwork>
            </figure>
            <t>
                It defines two rules, o1 and o2. o1 first specifies that an object can have
                zero or more (that is the meaning of "@*", see <xref target="repetition"></xref>)
                members where the member name is the letter 'p' followed by a number
                (e.g. "p0", "p1", "p2") and then a member with the exact member name "p1". o2
                has the exact same member specifications but in the opposite order.
            </t>
            <t>
                The following JSON will not match o1 but will match o2 because of the order
                of the member specifications.
            </t>
            <figure>
                <artwork align="center" xml:space="preserve">&object_order_eval.json;</artwork>
            </figure>
        </section>
        <section title="Array Specifications">
            <t>
                Array specifications define JSON arrays and are composed of zero or more subordinate
                components, each of which can either be a rule name or a primitive, array, object or
                group specification. The subordinate components are enclosed at the start with a left
                square brace character ('[') and at the end with a right square brace character (']').
            </t>
            <figure>
                <artwork align="center" xml:space="preserve">&array_example.jcr;</artwork>
            </figure>
            <t>
                Unlike object specifications, order is implied in array specifications by default.
                That is, the first subordinate component will match the first element of the array, 
                the second subordinate component will match the second element of the array, and so on.
            </t>
            <t>
                Take for example the following ruleset:
            </t>
            <figure>
                <artwork align="center" xml:space="preserve">&array_order_eval.jcr;</artwork>
            </figure>
            <t>
                It defines two rules, a1 and a2. The array in the following JSON will not match a1, but
                will match a2.
            </t>
            <figure>
                <artwork align="center" xml:space="preserve">&array_order_eval.json;</artwork>
            </figure>
            <t>
                Finally, if an array has more elements than can be matched from the array specification,
                the array does not match the array specification. Or stated differently, an array with unmatched
                elements does not validate. Using the example array rule a2 from above, the following
                array does not match because the last element of the array does not match any subordinate
                component:
            </t>
            <figure>
                <artwork align="center" xml:space="preserve">&array_order_eval2.json;</artwork>
            </figure>
            <section title="Unordered Array Specifications" anchor="unordered_array_specifications">
                <t>
                    Array specifications can be made to behave in a similar fashion to object specifications
                    with regard to the order of matching with the @{unordered} annotation.
                </t>
                <t>
                    In the ruleset below, a1 and a2 have the same subordinate components given in the
                    same order. a2 is annotated with the @{unordered} annotation.
                </t>
                <figure>
                    <artwork align="center" xml:space="preserve">&array_unordered_eval.jcr;</artwork>
                </figure>
                <t>
                    The JSON array below does not match a1 but does match a2.
                </t>
                <figure>
                    <artwork align="center" xml:space="preserve">&array_order_eval.json;</artwork>
                </figure>
                <t>
                    Like ordered array specifications, the subordinate components in an unordered array specification
                    are evaluated in the order they are specified. The difference is that they
                    need not match an element of the array in the same position as given in the
                    array specification.
                </t>
                <t>
                    Finally, like ordered array specifications, unordered array specifications also require that all elements of the array be
                    matched by a subordinate component. If the array has more elements than can be
                    matched, the array does not match the array specification.
                </t>
            </section>
        </section>
        <section title="Group Specifications" anchor="group_specifications">
            <t>
                Unlike the other type specifications, group specifications have no direct tie with JSON syntax.
                Group specifications simply group together their subordinate components. Group specfications
                enclose one or more suborindate components with the parenthesis characters.
            </t>
            <t>
                Group specifications and any nesting of group specifications, must conform
                to the allowable set of type specifications of the type specifications in which
                they are contained. For example, a group specification
                inside of an array specification may not contain a member specification since member specifications are not
                allowed as direct subordinates of array specifications (arrays contain values, not object members in JSON). 
                Likewise, a group specification referenced inside an object
                specification must only contain member specifictions (JSON objects may only contain object members).
            </t>
            <t>
                The following is an example of a group specification:
            </t>
            <figure>
                <artwork xml:space="preserve" align="center">&group_example.jcr;</artwork>
            </figure>    
            <t>
                Like the subordinate components of array and object specifications, the subordinate components of
                a group specification are evaluated in the order they appear.
            </t>
        </section>
            <section title="Ordered and Unordered Groups in Arrays">
                <t>
                    <xref target="unordered_array_specifications"></xref> specifies that arrays can be evaluated
                    by the order of the items in the array or can be evaluated without order.
                    <xref target="group_specifications"></xref> specifies that arrays may have group rules
                    as subordinate components.
                </t>
                <t>
                    The evaluation of a group specification inside an array specification inherits the ordering property
                    of the array specification. If the array specification is unordered, then the items of the group specification
                    are also considered to be unordered. And if the array specification is ordered, then the items
                    of the group specification are also considered to be ordered.
                </t>
            </section>
            <section title="Sequence and Choice Combinations in Array, Object, and Group Specifications">
                <t>
                    Combinations of subordinate components in array, object, and group specifications can be specified as either
                    a sequence ("and") or a choice ("or"). A sequence is a subordinate component followed by the comma character
                    (',') followed by another subordinate component.
                    A choice is a subordinate component followed by a pipe character ('|') followed by another subordinate component.
                </t>
                <figure>
                    <artwork align="center" xml:space="preserve">&and_or_example.jcr;</artwork>
                </figure>
                <t>
                    Sequence and choice combinations cannot be mixed, and group specifications must be used to
                    explicitly declare precedence between a sequence and a choice. Therefore, the following
                    is illegal:
                </t>
                <figure>
                    <artwork xml:space="preserve" align="center">&mixed_and_or_bad.jcr;</artwork>
                </figure>
                <t>
                    The example above should be expressed as:
                </t>
                <figure>
                    <artwork xml:space="preserve" align="center">&mixed_and_or_good.jcr;</artwork>
                </figure>
            </section>
            <section title="Repetition in Array, Object, and Group Rules" anchor="repetition">
                <t>
                    Evaluation of subordinate rules in array, object, and group rules may be preceded by
                    a repetition expression denoting how many times the subordinate rule should be
                    evaluated.
                </t>
                <t>
                    Repetition is expressed as a minimum number of repetitions and a maximum number of
                    repetitions. When no repetition expression is present, both the minimum and maximum
                    are 1.
                </t>
                <t>
                    A minimum and maximum can be expressed by giving the minimum followed by an asterisk
                    ('*') character followed by the maximum: min*max.
                    <list style="empty">
                        <t>[ 1*13 name_servers ] ; 1 to 13 name servers</t>
                    </list>
                    If the minimum is not given, it is assumed to be zero.
                    <list style="empty">
                        <t>{ *99 /eth.*/ mac_addr }; 0 to 99 ethernet addresses</t>
                    </list>
                    If the maximum is not given, it is assumed to be infinity.
                    <list style="empty">
                        <t>[ 2* octets ] ; two or more bytes</t>
                    </list>
                    If neither the minimum nor the maximum are given with the asterisk, this 
                    denotes "zero or more".
                    <list style="empty">
                        <t>error_set ( * error ) ; zero or more errors</t>
                    </list>
                </t>
                <t>
                    Repetition may also be expressed with a question mark character ('?') or a
                    plus character ('+'). '?' is equivalent to '0*1'.
                    <list style="empty">
                        <t>{ name, ?age } ; age is optional</t>
                    </list>
                    '+' is equivalent to '1*'
                    <list style="empty">
                        <t>[ + status ] ; 1 or more status values</t>
                    </list>
                </t>
            </section>
            <section title="Rejecting Rules" anchor="not_annotation">
                <t>
                    The evaluation of a rule can be changed with the @{reject} annotation. With this annotation,
                    a rule that would otherwise match does not, and a rule that would not have matched does.
                    <figure>
                        <artwork xml:space="preserve">
    not_two @{reject} : 2 
    ; match anything that isn't the integer 2
    
    @{reject} @{unordered} [ :"fail", *:string ] 
    ; error if one of the status values is "fail"
                </artwork>
                    </figure>         
                </t>
            </section>
            <section title="Repetitions, Annotations, and Target Rules">
                <t>
                    With regard to syntax, repetition expressions are part of the syntax of array, object, and group
                    rules with respect to the embedding of subordinate rules, whereas annotations are a component of
                    every type of rule definition. Every type of rule definition may begin with a series of
                    annotations.
                </t>
                <t>
                    The significance is the placement of repetition expressions with respect to annotations:
                    repetition expressions precede annotations.
                </t>
                <t>
                    The following is correct:
                    <list style="empty">
                        <t>[ * @{unordered} [ foo ] ]</t>
                    </list>
                    The following is not:
                    <list style="empty">
                        <t>[ @{unordered} * [ foo ] ]</t>
                    </list>
                </t>
            </section>
        </section>
        <section title="Directives">
            <t>
                Directives modify the processing of a ruleset. There are two forms of the directive, the 
                single line directive and the multi-line directive.
            </t>
            <t>
                Single line directives appear on their own line in a ruleset, begin
                with a hash character ('#') and are terminated by the end of the line.
                They take the following form:
                <list style="empty"><t># directive_name optional_directive_parameters</t></list>
                Directives may have other qualifiers after the directive name.
            </t>
            <t>
                Multi-line directives also appear on their own lines, but may span multiple lines.
                The being with the character sequence "#{" and ends with "}". The take the
                following form:
            </t>
            <figure>
                <artwork xml:space="preserve">
    #{ directive_name
         directive_parameter_1 directive_paramter_2
         directive_parameter_3
         ...
    }
                </artwork>
            </figure>
            <t>
                This specification defines the directives "jcr-version", "ruleset-id",
                and "import", but other directives may be defined.
            </t>
            <section title="jcr-version">
                <t>
                    This directive declares that the ruleset complies with a specific version of this
                    standard. The version is expressed as a major integer followed by a period followed
                    by a minor integer.
                    <list style="empty">
                        <t># jcr-version 0.6</t>
                    </list>
                </t>
                <t>
                    The major.minor number signifying compliance with this document is "0.6". Upon publication
                    of this specification as an IETF proposed standard, it will be "1.0".
                    <list style="empty">
                        <t># jcr-version 1.0</t>
                    </list>
                </t>
                <t>
                    Ruleset authors are advised to place this directive as the first line of a ruleset.
                </t>
            </section>
            <section title="ruleset-id">
                <t>
                    This directive identifies a ruleset to rule processors. It takes the form:
                    <list style="empty">
                        <t># ruleset-id identifier</t>
                    </list>
                </t>
                <t>
					An identifier can be a URL (e.g. http://example.com/foo), an inverted domain name
					(e.g. com.example.foo) or any other form that conforms to the JCR ABNF syntax that
					a ruleset author deems appropriate.  To a JCR processor the identifier is treated as
					an opague, case-sensitive string.
				</t>
            </section>            
            <section title="import">
                <t>
                    The import directive specifies that another ruleset is to have its rules
                    evaluated in addition to the ruleset where the directive appears.
                </t>
                <t>
                    This directive has the following form:
                    <list style="empty"><t># import identifier as alias</t></list>
                    The following is an example:
                    <list style="empty"><t># import http://example.com/rfc9999 as rfc9999</t></list>
                </t>
                <t>
                    The rule names of the ruleset to be imported may be referenced by prepending
                    the alias followed by a period character ('.') followed by the rule name
                    (i.e. "alias.name"). To continue the example above, if the ruleset at http://example.com/rfc9999
                    were to have a rule named 'encoding', rules in the ruleset importing it can
                    refer to that rule as 'rfc9999.encoding'.
                </t>
            </section>
        </section>
        <section title="Tips and Tricks">
            <section title="Any Member with Any Value">                
                <t>
                    Because member names may be specified with regular expressions, it is
                    possible to construct a member rule that matches any member name:
                    <list style="empty"><t>rule_name /.*/ target_rule_name</t></list>
                    As an example, the following defines an object member with any name
                    that has a value that is a string:
                    <list style="empty"><t>user_data /.*/ : string</t></list>
                </t>
                <t>
                    Constructing an object member of any name with any type would therefore
                    take the form:
                    <list style="empty"><t>rule_name /.*/ : any</t></list>
                </t>
            </section>
            <section title="Restricting Objects">   
                <t>
                    By default, members of objects which do not match a rule are ignored.
                    The reason for this validation model is due to the nature of the typical
                    access model to JSON objects in many programming languages, where members
                    of the object are obtained by referencing the member name. Therefore
                    extra members may exist without harm.
                </t>
                <t>
                    However, some specifications may need to restrict the members of a JSON
                    object to a known set. To construct an object rule specifying that no
                    extra members are expected, the @{reject} annotation may be used with
                    a regular expression as the last subordinate rule of the object rule.
                    <list style="empty">
                        <t>{ member1, member2, + @{reject} /.*/ : any }</t>
                    </list>
                </t>
                <t>
                    This works because subordinate rules are evaluated in the order they
                    appear in the object rule, and the last rule accepts any member with
                    any type but fails to validate if one ore more of those rules are found
                    due to the @{reject} annotation.
                </t>
            </section>
            <section title="Unrestricting Arrays">
                <t>
                    Unlike object validation, array rules will not validate items of an
                    array that do not match a subordinate rule of the array rule. This
                    processing model is due to the nature of the typical access pattern of
                    JSON arrays in many programming languages, which is to iterate over the
                    array. Processes iterating over an array would need to take special
                    steps for extra items of the array that are not specified, especially
                    if the items were of a different type than those that are expected.
                </t>
                <t>
                    Like object rules, the subordinate rules of an array rule are
                    evaluated in the order they appear. To allow an array to contain
                    any value after guaranteeing that it contains the necessary items,
                    the last subordinate rule of the array rule should accept any
                    item:
                    <list style="empty">
                        <t>[ item1, item2, * :any ]</t>
                    </list>
                </t>
            </section>
            <section title="Groups of Values">
                <t>
                    In addition to specific primitive data types, value rules may
                    contain a value choice rule. The value choice rule, and any subordinate rule
                    within it, must evaluate to a single primitive data type.
                </t>
                <t>
                    The following is an example of a value choice rule embedded in a value
                    rule:
                    <list style="empty">
                        <t>address : ( :ip4 | :ip6 )</t>
                    </list>
                </t>
            </section>
            <section title="Groups in Arrays"> 
                <t>
                    Groups may also be a subordinate rule of array rules:
                    <list style="empty">
                        <t>[ ( :ip4 | :ip6 ), :integer ]</t>
                    </list>
                </t>
                <t>
                    Unlike value rules, subordinate group rules in array rules
                    may have sequence combinations and contain any rule type
                    with the exception of member rules.
                    <list style="empty">
                        <t>[ ( first_name, ? middle_name, last_name ), age ]</t>
                    </list>
                    Of course, the above is better written as:
                    <list style="empty">
                        <t>[ name, age ]</t>
                        <t>name ( first_name, ? middle_name, last_name )</t>
                    </list>
                </t>
            </section>
            <section title="Groups in Objects">
                <t>
                    Groups may also be a subordinate rule of object rules:
                    <list style="empty">
                        <t>{ ( title, date, author ), + paragraph }</t>
                    </list>
                    Subordinate group rules in object rules may have sequence
                    combinations but must only contain member rules.
                </t>
                <figure>
                    <artwork xml:space="preserve">
    { front_matter, + paragraph }
    front_matter ( title, date, author )
    title "title" :string
    date "date" : full-date
    author "author" [ *:string ]
    paragraph /p[0-9]*/ :string
                </artwork>
                </figure> 
            </section>
            <section title="Group Rules as Macros">
                <t>
                    The syntax for group rules accommodates one ore more subordinate rules and
                    a repetition expression for each. Other than grouping multiple rules, a
                    group rule can be used as a macro definition for a single rule.
                    <list style="empty">
                        <t>paragraphs ( + /p[0-9]*/ : string )</t>
                    </list>
                </t>
            </section>
            <section title="Comment Separated Rules">
                <t>
                    Rules may be placed on the same line, but because they have no termination
                    syntax this style of writing rules can be confusing to some readers:
                    <list style="empty">
                        <t>first_name "first name" :string last_name "last name" :string</t>
                    </list>
                </t>
                <t>
                    An empty comment can serve as a visual cue to denote the separation of the
                    two rules:
                    <list style="empty">
                        <t>first_name "first name" :string ;; last_name "last name" :string</t>
                    </list>
                </t>
            </section>
            <section title="Object Mixins">
                <t>
                    Group rules can be used to create object mixins, a pattern for writing data
                    models similar in style to object derivation in some programming languages.
                    In the example in <xref target="group_mixin_example"></xref>,
                    both obj1 and obj2 have a members "foo" and "fob" with obj1 having the additional member "bar"
                    and obj2 having the additional member "baz".
                </t>
                <figure anchor="group_mixin_example">
                    <artwork xml:space="preserve">
mixin_group ( "foo" : integer, "fob" : uri )

obj1 { mixin_group, "bar" : string }

obj2 { mixin_group, "baz" : string }
                </artwork>
                </figure>
            </section>
            <section title="Subordinate Rule Dependencies">
                <t>
                    In object and array rules, there may be situations in which it is necessary to
                    condition the existence of a subordinate rule on the existence of a sibling subordinate
                    rule. In other words, example_rule_two should only be evaluated if example_rule_one
                    evaluates positively. Or put another way, a member of an object or an item of an
                    array may be present only on the condition that another member of item is present.
                </t>
                <t>
                    In the following example, the referrer_uri member can only be present if the
                    location_uri member is present.
                    <list style="empty"><t>response { ?( location_uri, ?referrer_uri ) }</t></list>
                </t>
            </section>
            <section title="Multiple Root Styles">
                <t>
                    As stated in <xref target="starting-points"></xref>, the first rule in a ruleset
                    is a root rule when it is unnamed. Group rules can be used as the root rule, such
                    as in the following example:
                </t>
                <figure>
                    <artwork xml:space="preserve">
    ( { "foo" : string } | { "bar" : string } )
                    </artwork>
                </figure>
                <t>
                    This is the equivalent of the following:
                </t>
                <figure>
                    <artwork xml:space="preserve">
    foo @{root} { "foo" : string }
    bar @{root} { "bar" : string }
                    </artwork>
                </figure>
                <t>
                    Either style is valid. However, explicitly naming root rules has the advantage
                    of explicitly validating a JSON message against a specific rule.
                </t>
            </section>
            <section title="JSON-like Object and Array Definitions">
                <t>
                    JCR allows an optional colon character (":") to precede object and array rule
                    definitions to give these definitions more of a JSON-like appearance.
                    Consider the following example.
                </t>
                <figure>
                    <artwork xml:space="preserve">
    { 
        "foo" { 
            "fuzz" : string 
         }, 
         "bar" [ 
             "baz" 
         ] 
     }
                    </artwork>
                </figure> 
                <t>
                    To appear more JSON-like, this may also be given as follows:
                </t>
                <figure>
                    <artwork xml:space="preserve">
    { 
        "foo" : { 
            "fuzz" : string 
         }, 
         "bar" : [ 
             "baz" 
         ] 
     }
                    </artwork>
                </figure> 
            </section>
        </section>
        <section title="ABNF Syntax">
            <figure title="ABNF for JSON Content Rules" anchor="abnf">
                <preamble>
                    The following ABNF describes the syntax for JSON Content Rules.
                </preamble>
                <artwork xml:space="preserve">&ABNF;</artwork>
            </figure>
        </section>        
        <section title="Acknowledgements">
            <t>
                Andrew Biggs and Paul Jones provided feedback and suggestions
                which led to many changes in the syntax.
            </t>
        </section>
    </middle>
    <back>
        <references title="Normative References">
            
            &RFC1166;
            &RFC3339;
            &RFC3986;
            &RFC4234;
            &RFC4648;
            &RFC5322;
            &RFC5952;
            &RFC6570;
            &RFC7159;
            
        </references>
        <references title="Infomative References">
            
            &I-D.cordell-jcr-co-constraints;
            
            <reference anchor="ARIN_JCR_VALIDATOR" target="https://github.com/arineng/jcrvalidator">
                <front>
                    <title>JSON Content Rules Validator (Work In Progress)</title>
                    <author>
                        <organization>American Registry for Internet Numbers</organization>
                    </author>
                    <date/>
                </front>
            </reference>
            <reference anchor="CODALOGIC_JCR_VALIDATOR" target="https://github.com/codalogic/cl-jcr-parser">
                <front>
                    <title>cl-jcr-parser (Work In Progress)</title>
                    <author>
                        <organization>Codalogic</organization>
                    </author>
                    <date/>
                </front>
            </reference>
        </references>
        <section title="Co-Constraints">
            <t>
                This specification defines a small set of annotations and directives for JCR, yet
                the syntax is extensible allowing for other annotations and directives.
                <xref target="I-D.cordell-jcr-co-constraints"></xref> ("Co-Constraints for JCR") defines further
                annotations and directives which define more detailed constraints on JSON
                messages, including co-constraints (constraining parts of JSON message based
                on another part of a JSON message).
            </t>
        </section>
        <section title="Testing Against JSON Content Rules">
            <t>
                One aspect of JCR that differentiates it from other format schema languages are
                the mechanisms helpful to developers for taking a formal specification, such as
                that found in an RFC, and evolving it into unit tests, which are essential to
                producing quality protocol implementations.
            </t>
            <section title="Locally Overriding Rules">
                <t>
                    As mentioned in the introduction, one tool for testing would be the
                    ability to locally override named rules. As an example, consider the
                    following rule which defines an array of strings.
                    <list style="empty">
                        <t>statuses [ * :string ]</t>
                    </list>
                    Consider the specification where this rule is found does not define the
                    values but references an IANA registry for extensibility purposes.
                </t>
                <t>
                    If a software developer desired to test a specific situation in which the
                    array must at least contain the status "accepted", the rules from the specification
                    could be used and the statuses rule could be explicitly overridden locally as:
                    <list style="empty">
                        <t>statuses @{unordered} [ :"accepted", * :string ]</t>
                    </list>
                </t>
                <t>
                    Alternatively, the developer may need to ensure that the status "denied" should
                    not be present in the array:
                    <list style="empty">
                        <t>statuses @{unordered} [ ? @{reject} :"denied", * :string ]</t>
                    </list>
                </t>
            </section>
            <section title="Rule Callbacks">
                <t>
                    In many testing scenarios, the evaluation of rules may become more complex
                    than that which can be expressed in JCR, sometimes involving variables and
                    interdependencies which can only be expressed in a programming language.
                </t>
                <t>
                    A JCR processor may provide a mechanism for the execution of local functions
                    or methods based on the name of a rule being evaluated. Such a mechanism
                    could pass to the function the data to be evaluated, and that function could
                    return to the processor the result of evaluating the data in the function.
                </t>
            </section>
        </section>
        <section title="JCR Implementations">
            <t>
                The following implementations, <xref target="ARIN_JCR_VALIDATOR"></xref> and
                <xref target="CODALOGIC_JCR_VALIDATOR"></xref> have influenced the development
                of this document.
            </t>
        </section>
    </back>
</rfc>
