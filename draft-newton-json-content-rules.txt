



Network Working Group                                          A. Newton
Internet-Draft                                                      ARIN
Intended status: Standards Track                              P. Cordell
Expires: January 6, 2017                                       Codalogic
                                                            July 5, 2016


              A Language for Rules Describing JSON Content
                   draft-newton-json-content-rules-07

Abstract

   This document describes a language for specifying and testing the
   expected content of JSON structures found in JSON-using protocols,
   software, and processes.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on January 6, 2017.

Copyright Notice

   Copyright (c) 2016 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.




Newton & Cordell         Expires January 6, 2017                [Page 1]

Internet-Draft             JSON Content Rules                  July 2016


Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
     1.1.  A First Example: Specifying Content . . . . . . . . . . .   3
     1.2.  A Second Example: Testing Content . . . . . . . . . . . .   3
   2.  Overview of the Language  . . . . . . . . . . . . . . . . . .   4
   3.  Lines and Comments  . . . . . . . . . . . . . . . . . . . . .   6
   4.  Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . .   7
     4.1.  Rule Names and Assignments  . . . . . . . . . . . . . . .   7
     4.2.  Annotations . . . . . . . . . . . . . . . . . . . . . . .   8
     4.3.  Starting Points and Root Rules  . . . . . . . . . . . . .   8
     4.4.  Type Specifications . . . . . . . . . . . . . . . . . . .   9
     4.5.  Primitive Specifications  . . . . . . . . . . . . . . . .  10
       4.5.1.  Numbers, Booleans and Null  . . . . . . . . . . . . .  10
       4.5.2.  Strings . . . . . . . . . . . . . . . . . . . . . . .  11
     4.6.  Any Type  . . . . . . . . . . . . . . . . . . . . . . . .  13
     4.7.  Member Specifications . . . . . . . . . . . . . . . . . .  13
     4.8.  Object Rules  . . . . . . . . . . . . . . . . . . . . . .  13
     4.9.  Array Rules . . . . . . . . . . . . . . . . . . . . . . .  14
       4.9.1.  Unordered Array Rules . . . . . . . . . . . . . . . .  15
     4.10. Group Rules . . . . . . . . . . . . . . . . . . . . . . .  16
     4.11. Ordered and Unordered Groups in Arrays  . . . . . . . . .  16
     4.12. Sequence and Choice Combinations in Array, Object, and
           Group Rules . . . . . . . . . . . . . . . . . . . . . . .  16
     4.13. Repetition in Array, Object, and Group Rules  . . . . . .  17
     4.14. Rejecting Rules . . . . . . . . . . . . . . . . . . . . .  18
     4.15. Repetitions, Annotations, and Target Rules  . . . . . . .  18
   5.  Directives  . . . . . . . . . . . . . . . . . . . . . . . . .  18
     5.1.  jcr-version . . . . . . . . . . . . . . . . . . . . . . .  19
     5.2.  ruleset-id  . . . . . . . . . . . . . . . . . . . . . . .  19
     5.3.  import  . . . . . . . . . . . . . . . . . . . . . . . . .  20
   6.  Tips and Tricks . . . . . . . . . . . . . . . . . . . . . . .  20
     6.1.  Any Member with Any Value . . . . . . . . . . . . . . . .  20
     6.2.  Restricting Objects . . . . . . . . . . . . . . . . . . .  20
     6.3.  Unrestricting Arrays  . . . . . . . . . . . . . . . . . .  21
     6.4.  Groups of Values  . . . . . . . . . . . . . . . . . . . .  21
     6.5.  Groups in Arrays  . . . . . . . . . . . . . . . . . . . .  22
     6.6.  Groups in Objects . . . . . . . . . . . . . . . . . . . .  22
     6.7.  Group Rules as Macros . . . . . . . . . . . . . . . . . .  22
     6.8.  Comment Separated Rules . . . . . . . . . . . . . . . . .  22
     6.9.  Object Mixins . . . . . . . . . . . . . . . . . . . . . .  23
     6.10. Subordinate Rule Dependencies . . . . . . . . . . . . . .  23
     6.11. Multiple Root Styles  . . . . . . . . . . . . . . . . . .  23
     6.12. JSON-like Object and Array Definitions  . . . . . . . . .  24
   7.  ABNF Syntax . . . . . . . . . . . . . . . . . . . . . . . . .  24
   8.  Acknowledgements  . . . . . . . . . . . . . . . . . . . . . .  29
   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  29
     9.1.  Normative References  . . . . . . . . . . . . . . . . . .  29



Newton & Cordell         Expires January 6, 2017                [Page 2]

Internet-Draft             JSON Content Rules                  July 2016


     9.2.  Infomative References . . . . . . . . . . . . . . . . . .  30
   Appendix A.  Co-Constraints . . . . . . . . . . . . . . . . . . .  30
   Appendix B.  Testing Against JSON Content Rules . . . . . . . . .  30
     B.1.  Locally Overriding Rules  . . . . . . . . . . . . . . . .  31
     B.2.  Rule Callbacks  . . . . . . . . . . . . . . . . . . . . .  31
   Appendix C.  JCR Implementations  . . . . . . . . . . . . . . . .  31
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  31

1.  Introduction

   This document describes JSON Content Rules (JCR), a language for
   specifying and testing the interchange of data in JSON [RFC7159]
   format used by computer protocols and processes.  The syntax of JCR
   is not JSON but is "JSON-like", possessing the conciseness and
   utility that has made JSON popular.

1.1.  A First Example: Specifying Content

   The following JSON data describes a JSON object with two members,
   "line-count" and "word-count", each containing an integer.

               { "line-count" : 3426, "word-count" : 27886 }

   This is also JCR that describes a JSON object with a member named
   "line-count" that is an integer that is exactly 3426 and a member
   named "word-count" that is an integer that is exactly 27886.

   For a protocol specification, it is probably more useful to specify
   that each member is any integer and not specific, exact integers:

            { "line-count" : integer, "word-count" : integer }

   Since line counts and word counts should be either zero or a positive
   integer, the specification may be further narrowed:

                { "line-count" : 0.. , "word-count" : 0.. }

1.2.  A Second Example: Testing Content

   Building on the first example, this second example describes the same
   object but with the addition of another member, "file-name".

                      {
                        "file-name"  : "rfc7159.txt",
                        "line-count" : 3426,
                        "word-count" : 27886
                      }




Newton & Cordell         Expires January 6, 2017                [Page 3]

Internet-Draft             JSON Content Rules                  July 2016


   The following JCR describes objects like it.

                         {
                           "file-name"  : string,
                           "line-count" : 0..,
                           "word-count" : 0..
                         }

   For the purposes of writing a protocol specification, JCR may be
   broken down into named rules to reduce complexity and to enable re-
   use.  The following example takes the JCR from above and rewrites the
   members as named rules.

                        {
                          $fn,
                          $lc,
                          $wc
                        }

                        $fn = "file-name"  : string
                        $lc = "line-count" : 0..
                        $wc = "word-count" : 0..

   With each member specified as a named rule, software testers can
   override them locally for specific test cases.  In the following
   example, the named rules are locally overridden for the test case
   where the file name is "rfc4627.txt".

                    $fn = "file-name"  : "rfc4627.txt"
                    $lc = "line-count" : 2102
                    $wc = "word-count" : 16714

   In this example, the protocol specification describes the JSON object
   in general and an implementation overrides the rules for testing
   specific cases.

2.  Overview of the Language

   JCR is composed of rules (as the name suggests).  A collection of
   rules that is processed together is a ruleset.  Rulesets may also
   contain comments, blank lines, and directives that apply to the
   processing of a ruleset.

   Rules are composed of two parts, an optional rule name assignment and
   a type specification.  Rules may be defined across line boundaries
   and there is no line continuation syntax.  The type specification
   component of rules are a superset of JSON.




Newton & Cordell         Expires January 6, 2017                [Page 4]

Internet-Draft             JSON Content Rules                  July 2016


   Rules with rule name assignments may be referenced in the type
   specifications of other rules.  And type specifications, depending on
   their type, may be composed of other type specifications.  Type
   specifications define arrays, objects, members of objects, primitive
   types, and groups of types.

   Any rule consisting only of a type specification is considered a root
   rule.  Unless otherwise specified, all the root rules of a ruleset
   are evaluated against a JSON instance or document.

   Putting it all together, Figure 2 describes the JSON in Figure 1.

   Example JSON shamelessly lifted from RFC 4627

         {
           "Image": {
             "Width":  800,
             "Height": 600,
             "Title":  "View from 15th Floor",
             "Thumbnail": {
               "Url":    "http://www.example.com/image/481989943",
               "Height": 125,
               "Width":  100
             },
             "IDs": [116, 943, 234, 38793]
           }
         }

                                 Figure 1






















Newton & Cordell         Expires January 6, 2017                [Page 5]

Internet-Draft             JSON Content Rules                  July 2016


   Rules describing Figure 1

      ; the root of the JSON instance is an object
      ; this root rule describes that object
      {

        ; he object specification contains one member specification
        "Image" : {

          ; $width and $height are defined below
          $width,
          $height,

          ; "Title" member specification
          "Title" :string,

          ; "Thumbnail" member specification, which defines an object
          "Thumbnail":  {

            ; $width and $height are re-used again
            $width, $height,

            "Url" :uri
          },

          ; "IDs" member that is an array of one ore more integers
          "IDs" : [ integer @* ]

        }
      }

      ; The definitions of the rules $width and $height
      $width  = "Width" : 0..1280
      $height = "Height" : 0..1024


                                 Figure 2

3.  Lines and Comments

   There is no statement terminator and therefore no need for a line
   continuation syntax.  Rules may be defined across line boundaries.
   Blank lines are allowed.

   Comments are very similar to comments in ABNF [RFC4234].  They start
   with a semi-colon (';') and continue to the end of the line or
   another semi-colon.




Newton & Cordell         Expires January 6, 2017                [Page 6]

Internet-Draft             JSON Content Rules                  July 2016


4.  Rules

   Rules have two main components, an optional rule name assignment and
   a type specification.  Type specifications define arrays, objects,
   etc... of JSON and may reference other rules using rule names.  Most
   type specifications can be defined with repetitions for specifying
   the frequency of the type being defined.  In addition to the type
   specifications describing JSON types, there is an additional group
   specification for grouping types.

   Rules may also contain annotations which may affect the evaluation of
   all or part of a rule.  Rules without a rule name assignment are
   considered root rules, though rules with a rule name assignment can
   be considered a root rule with the appropriate annotation.

4.1.  Rule Names and Assignments

   Rule names are signified with the dollar character ('$'), which is
   not part of the rule name itself.  Rule names have two components, an
   optional ruleset identifier and a local rule name.

   Local rule names must start with an alphabetic character (a-z,A-Z)
   and must contain only alphabetic characters, numeric characters, the
   hyphen character ('-') and the underscore character ('_').  Local
   rule names are case sensitive, and must be unique within a ruleset
   (that is, no two rule name assignements may use the same local rule
   name).

   Ruleset identifiers reference rules from another ruleset.  They are
   not allowed in rule name assignments, and only found in the directive
   specifying the ruleset identifier for a ruleset and rule names
   referenced by other rules.  Ruleset identifiers must start with an
   alphabetic character and contain no whitespace.  Ruleset identifiers
   are case sensitive.  Simple use cases of JCR will most likely not use
   ruleset identifiers.

          # import http://ietf.org/rfcXXXX.JCR as rfcXXXX
          $my_encodings  = ( "mythic" | "magic" )
          $all_encodings = ( $rfcXXXX.encodings | $my_encodings )

   There are two forms of rule name assignments, assignements of
   primitive types and assignments of all other types.  Rule name
   assignments to primitive type specifications separate the rule name
   from the type specification with the character sequence '=:', whereas
   rule name assignments for all other type specifications only require
   the separation using the '=' character.





Newton & Cordell         Expires January 6, 2017                [Page 7]

Internet-Draft             JSON Content Rules                  July 2016


                ;rule name assignments for primitive types
                $foo         =: "foo"
                $some_string =: string

                ;rule name assignments for arrays
                $bar = [ integer, integer, integer ]

                ;rule name assignement for objects
                $bob = { "bar" : $bar, "foo" : $foo }


   This is the one little "gotcha" in JCR.  This syntax is necessary so
   that JCR parsers may distinguish between rules name assignments
   involving primitives and object member type specifications involving
   primitives.

4.2.  Annotations

   Annotations may appear before a rule name assignment, before a type
   specification, or before a rule name contained within a type
   specification.  In each place, there may be zero or more annotations.
   Each annotation begins with the character sequence "@{" and ends with
   "}".  The following is an example of a type specification with the
   not annotation (explained in Section 4.14):

      @{not} [ $fruit, $vegatable ]

   This specification defines the annotations "root", "not", and
   "unordered", but other annotations may be defined for other purposes.

4.3.  Starting Points and Root Rules

   Evaluation of a JSON instance or document against a ruleset begins
   with the evaluation of a root rule or set of root rules.  If no root
   rule (or rules) is specified locally at runtime, the set of root
   rules specified in the ruleset are evaluated.  The order of
   evaluation is undefined.

   The set of root rules specified in a ruleset is composed of all rules
   without a rule name assignment and all rules annotated with the
   "@{root}" annotation.

   The "@{root}" annotation may either appear before a rule name
   assignment or before a type definition.  It is ignored if present
   before referenced rule name inside of a type specification.






Newton & Cordell         Expires January 6, 2017                [Page 8]

Internet-Draft             JSON Content Rules                  July 2016


4.4.  Type Specifications

   The syntax of each type of type specifications varies depending on
   the type:

      ; primitive types can be string
      ; or number literals
      ; or number ranges
      "foo"
      2
      1..10

      ; primitive types can also be more generalized types
      string
      integer

      ; member specifications consist of a member name
      ; followed by a colon and then followed by another
      ; type specification or a rule name
      ; (example shown with a rule name assignment)
      $mem1 = "bar" : "baz"

      ; member names may either be quoted strings
      ; or regular expressions
      ; (example shown with a rule name assignment)
      $mem2 = /dev[0-9]/ : 0..4096

      ; object specifications start and end with "curly braces"
      ; object specifications contain zero
      ; or more member specifications
      ; or rule names which reference a member specification
      { $mem1, "foo" : "fuzz" }

      ; array specifications start and end with square brackets
      ; array specifications contain zero
      ; or more non-member type specifications
      [ 1, 2, 3, $item1 ]
      $item1 =: 4

      ; finally, group specifications start and end with parenthesis
      ; groups contain other type specifications
      ( [ integer, integer], $rule1 )
      $rule1 = [ string, string ]








Newton & Cordell         Expires January 6, 2017                [Page 9]

Internet-Draft             JSON Content Rules                  July 2016


4.5.  Primitive Specifications

   Primitive type specifications define content for JSON numbers,
   booleans, strings, and null.

4.5.1.  Numbers, Booleans and Null

   The rules for booleans and null are the simplest and take the
   following forms:

                                  true
                                  false
                                  boolean
                                  null

   Rules for numbers can specify the number be either an integer or
   floating point number:

                                  integer
                                  float

   Numbers may also be specified as an absolute value or a range of
   possible values, where a range may be specified using a minimum,
   maximum, or both:

                                   n
                                   n..m
                                    ..m
                                   n..
                                 n.f
                                 n.f..m.f
                                    ..m.f
                                 n.f..

   When specifying a minimum and a maximum, both must either be an
   integer or a floating point number.  Thus to specify a floating point
   number between zero and ten a definition of the following form is
   used:

                                 0.0..10.0


   Integers may also be specified as ranges using bit lengths preceded
   by the 'int' or 'uint' words (i.e. 'int8', 'uint16').  The 'int' word
   specifies the integer as being signed whereas the 'uint' word
   specifies the integer as being unsigned.





Newton & Cordell         Expires January 6, 2017               [Page 10]

Internet-Draft             JSON Content Rules                  July 2016


                ; 0..255
                uint8

                ; -32768..32767
                int16

                ; 0..65535
                uint16

                ; -9223372036854775808..9223372036854775807
                int64

                ; 0..18446744073709551615
                uint64

4.5.2.  Strings

   JCR provides a large number of data types to define the contents of
   JSON strings.  Generically, a string may be specified using the word
   'string'.  String literals may be specified using a double quote
   character followed by the literal content followed by another double
   quote.  And regular expressions may be specified by enclosing a
   regular expression in the forward slash ('/') character.

                          ; any string
                          string

                          ; a string literal
                          "she sells sea shells"

                          ; a regular expression
                          /she sells .*/

   A string can be specified as a URI [RFC3986] using the word 'uri',
   but also may be more narrowly specified using a URI template
   [RFC6570].  URI templates are specified with the word 'uri' followed
   by two period characters ('..') followed by the URI template.  When
   using URI templates, the variable names are ignored for pattern
   matching, but they should be provided for construction of a valid URI
   template.  Providing the variable names also aids in the description
   of what is to be matched.










Newton & Cordell         Expires January 6, 2017               [Page 11]

Internet-Draft             JSON Content Rules                  July 2016


               ; any URI
               uri

               ;a URI template for an HTTPS uri
               uri..https://{stuff}

               ;a more specific URI template
               uri..https://{authority}/{thing1}?q={thing2}

   IP addresses may be specified with either the word 'ipv4' for IPv4
   addresses [RFC1166] or the word 'ipv6' for IPv6 addresses [RFC5952].
   Fully qualified A-label and U-label domain names may be specified
   with the words 'fqdn' and 'idn'.

   Dates and time can be specified as formats found in RFC 3339
   [RFC3339].  The word 'date' corresponds to the full-date ABNF rule,
   the word 'time' corresponds to the full-time ABNF rule, and the word
   'datetime' corresponds to the 'date-time' ABNF rule.

   Email addresses formatted according to RFC 5322 [RFC5322] may be
   specified using the 'email' word, and E.123 phone number may be
   specified using the word 'phone'.

                         ;IP addresses
                         ipv4
                         ipv6

                         ;domain names
                         fqdn
                         idn

                         ; RFC 3339 full-date
                         date
                         ; RFC 3339 full-time
                         time
                         ; RFC 3339 date-time
                         datetime

                         ; RFC 5322 email address
                         email

                         ; phone number
                         phone

   Binary date can be specified in string form using the encodings
   specified in RFC 4648 [RFC4648].  The word 'hex' corresponds to
   base16, while 'base32', 'base32hex', 'base64', and 'base64url'
   accordingly.



Newton & Cordell         Expires January 6, 2017               [Page 12]

Internet-Draft             JSON Content Rules                  July 2016


                           ; RFC 4648 base16
                           hex

                           ; RFC 4648 base32
                           base32

                           ; RFC 4648 base32hex
                           base32hex

                           ; RFC 4648 base64
                           base64

                           ; RFC 4648 base64url
                           base64url

4.6.  Any Type

   It is possible to specify that a value can be of any type allowable
   by JSON using the word 'any'.  The 'any' type specifies any primitive
   type, array, or object.

4.7.  Member Specifications

   Member specifications define members of JSON objects.  Unlike other
   type specfications, member specifications cannot be root rules and
   must be part of an object specification or preceded by a rule name
   assignment.

   Member specifications consist of a member name specification followed
   by a colon character (':') followed by either a rule name or a
   primitive, object, array, or group specification.  Member name
   specifications can be given either as a quated string using double
   quotes or as a regular expression using forward slash ('/')
   characters.

            ;member name will exactly match "locationURI"
            $location_uri = "locationURI" : uri

            ;member name will match "eth0", "eth1", ... "eth9"
            $iface_mappings = /eth[0-9]/  : ipv4

4.8.  Object Rules

   Object rules define the allowable members of a JSON object, and their
   rule definitions contain the member rules of the object.  They take
   the following form:

      rule_name { member_rule_1, member_rule_2 }



Newton & Cordell         Expires January 6, 2017               [Page 13]

Internet-Draft             JSON Content Rules                  July 2016


   The following rule example defines an object composed of two member
   rules:

      response { location_uri, status_code }

   Given that where a rule name is found a rule definition of an
   appropriate type may be used, the above example might also be written
   as:

      response { "locationUri" : uri, "statusCode" : integer }

   Rules given in the rule definition of an object rule do not imply
   order.  Given the example object rule above both

      { "locationUri" : "http://example.com", "statusCode" : 200 }

   and

      { "statusCode" : 200, "locationUri" : "http://example.com" }

   are JSON objects that match the rule.

   Each member rule of an object rule is evaluated in the order in which
   they appear in the object rule.  Thus where there is potential
   conflict between rule names defined using regular expressions, the
   rules with the most constrained name should be defined first.
   Otherwise, for example, a rule definition of:

      { /p\d+/ : int, "p0" : string }

   would fail to match the JSON object:

      { "p1" : 12, "p0" : "Fred" }

   because the "p0" member name would match the regular expression
   despite the presence of the subsequently defined "p0" member rule.

4.9.  Array Rules

   Array rules define the allowable content of JSON arrays.  Their rule
   definitions are composed of the other rule types with the exception
   of member rules and have the following form:

      rulename [ rule_1, rule_2 ]

   The following example defines an array where the first element is
   defined by the width_value rule and the second element is defined by
   the height_value rule:



Newton & Cordell         Expires January 6, 2017               [Page 14]

Internet-Draft             JSON Content Rules                  July 2016


      size [ width_value, height_value ]

   By default, unlike object rules, order is implied by the array rule
   definition.  That is, the first rule referenced or defined within an
   array rule specifies that the first element of the array will match
   that rule, the second rule given with the array rule specifies that
   the second element of the array will match that rule, and so on.

   Take for example the following array rule definition:

      person [ : string, : integer ]

   This JSON array matches the above rule:

      [ "Bob Smurd", 24 ]

   while this one does not:

      [ 24, "Bob Smurd" ]

   Finally, if an array has more elements than can be matched from the
   array rule, the array does not match the array rule.  Or stated
   differently, an array with unmatched elements does not validate.
   Using the example array rule above, the following array does not
   match because the last element of the array does not match any rule
   contained in the array rule:

      [ "Bob Smurd", 24, "http://example.com/bob-smurd" ]

4.9.1.  Unordered Array Rules

   Array rules can be made to behave in a similar fashion to object
   rules with regard to the order of matching with the @{unordered}
   annotation:

      person @{unordered} [ :string, :integer ]

   This rule matches both of theses JSON arrays.

      [ "Bob Smurd", 24 ]

      [ 24, "Bob Smurd" ]

   Like ordered array rules, the rules contained in an unordered array
   rule are evaluated in the order they are specified.  The difference
   is that they need not match an element of the array in the same
   position as given in the array rule.




Newton & Cordell         Expires January 6, 2017               [Page 15]

Internet-Draft             JSON Content Rules                  July 2016


   Like ordered array rules, unordered array rules also require that all
   elements of the array be matched by a subordinate rule.  If the array
   has more elements than can be matched, the array rule does not match
   the array.

4.10.  Group Rules

   Unlike the other types of rules, group rules have no direct tie with
   JSON syntax.  Group rules simply group together other rules.  They
   take the form:

      rule_name ( target_rule_1, target_rule_2 )

   Group rule definitions and any nesting of group rule definitions,
   must conform to the allowable set of rules of the rule containing
   them.  A group rule referenced inside of an array rule may not
   contain a member rule since member rules are not allowed in array
   rules directly.  Likewise, a group rule referenced inside an object
   rule must only contain member rules.

   The following is an example of a group rule:

       the_bradys [ parents, children ]
       children ( :"Greg", :"Marsha", :"Bobby", :"Jan" )
       parents ( :"Mike", :"Carol" )

   Like the subordinate rules of array and object rules, the subordinate
   rules of a group rule are evaluated in the order they appear.

4.11.  Ordered and Unordered Groups in Arrays

   Section 4.9.1 specifies that arrays can be evaluated by the order of
   the items in the array or can be evaluated without order.
   Section 4.10 specifies that arrays may have group rules as
   subordinates.

   The evaluation of a group rule inside an array rule inherits the
   ordering property of the array rule.  If the array rule is unordered,
   then the items of the group rule are also considered to be unordered.
   And if the array rule is ordered, then the items of the group rule
   are also considered to be ordered.

4.12.  Sequence and Choice Combinations in Array, Object, and Group
       Rules

   Combinations of subordinate rules in array, object, and group rules
   can be specified as either a sequence ("and") or a choice ("or").  A




Newton & Cordell         Expires January 6, 2017               [Page 16]

Internet-Draft             JSON Content Rules                  July 2016


   sequence is a rule followed by the comma character (',') followed by
   another rule.

      [ this, that ]

   A choice is a rule followed by a pipe character ('|') followed by
   another rule.

      [ this | that ]

   Sequence and choice combinations cannot be mixed, and group rules
   must be used to explicitly declare precedence between a sequence and
   a choice.  Therefore, the following is illegal:

       [ this, that | the_other ]

   The example above should be expressed as:

       [ this, ( that | the_other ) ]

4.13.  Repetition in Array, Object, and Group Rules

   Evaluation of subordinate rules in array, object, and group rules may
   be preceded by a repetition expression denoting how many times the
   subordinate rule should be evaluated.

   Repetition is expressed as a minimum number of repetitions and a
   maximum number of repetitions.  When no repetition expression is
   present, both the minimum and maximum are 1.

   A minimum and maximum can be expressed by giving the minimum followed
   by an asterisk ('*') character followed by the maximum: min*max.

      [ 1*13 name_servers ] ; 1 to 13 name servers

   If the minimum is not given, it is assumed to be zero.

      { *99 /eth.*/ mac_addr }; 0 to 99 ethernet addresses

   If the maximum is not given, it is assumed to be infinity.

      [ 2* octets ] ; two or more bytes

   If neither the minimum nor the maximum are given with the asterisk,
   this denotes "zero or more".

      error_set ( * error ) ; zero or more errors




Newton & Cordell         Expires January 6, 2017               [Page 17]

Internet-Draft             JSON Content Rules                  July 2016


   Repetition may also be expressed with a question mark character ('?')
   or a plus character ('+'). '?' is equivalent to '0*1'.

      { name, ?age } ; age is optional

   '+' is equivalent to '1*'

      [ + status ] ; 1 or more status values

4.14.  Rejecting Rules

   The evaluation of a rule can be changed with the @{reject}
   annotation.  With this annotation, a rule that would otherwise match
   does not, and a rule that would not have matched does.

       not_two @{reject} : 2
       ; match anything that isn't the integer 2

       @{reject} @{unordered} [ :"fail", *:string ]
       ; error if one of the status values is "fail"

4.15.  Repetitions, Annotations, and Target Rules

   With regard to syntax, repetition expressions are part of the syntax
   of array, object, and group rules with respect to the embedding of
   subordinate rules, whereas annotations are a component of every type
   of rule definition.  Every type of rule definition may begin with a
   series of annotations.

   The significance is the placement of repetition expressions with
   respect to annotations: repetition expressions precede annotations.

   The following is correct:

      [ * @{unordered} [ foo ] ]

   The following is not:

      [ @{unordered} * [ foo ] ]

5.  Directives

   Directives modify the processing of a ruleset.  There are two forms
   of the directive, the single line directive and the multi-line
   directive.






Newton & Cordell         Expires January 6, 2017               [Page 18]

Internet-Draft             JSON Content Rules                  July 2016


   Single line directives appear on their own line in a ruleset, begin
   with a hash character ('#') and are terminated by the end of the
   line.  They take the following form:

      # directive_name optional_directive_parameters

   Directives may have other qualifiers after the directive name.

   Multi-line directives also appear on their own lines, but may span
   multiple lines.  The being with the character sequence "#{" and ends
   with "}".  The take the following form:

       #{ directive_name
            directive_parameter_1 directive_paramter_2
            directive_parameter_3
            ...
       }

   This specification defines the directives "jcr-version", "ruleset-
   id", and "import", but other directives may be defined.

5.1.  jcr-version

   This directive declares that the ruleset complies with a specific
   version of this standard.  The version is expressed as a major
   integer followed by a period followed by a minor integer.

      # jcr-version 0.6

   The major.minor number signifying compliance with this document is
   "0.6".  Upon publication of this specification as an IETF proposed
   standard, it will be "1.0".

      # jcr-version 1.0

   Ruleset authors are advised to place this directive as the first line
   of a ruleset.

5.2.  ruleset-id

   This directive identifies a ruleset to rule processors.  It takes the
   form:

      # ruleset-id identifier

   An identifier can be a URL (e.g. http://example.com/foo), an inverted
   domain name (e.g. com.example.foo) or any other form that conforms to
   the JCR ABNF syntax that a ruleset author deems appropriate.  To a



Newton & Cordell         Expires January 6, 2017               [Page 19]

Internet-Draft             JSON Content Rules                  July 2016


   JCR processor the identifier is treated as an opague, case-sensitive
   string.

5.3.  import

   The import directive specifies that another ruleset is to have its
   rules evaluated in addition to the ruleset where the directive
   appears.

   This directive has the following form:

      # import identifier as alias

   The following is an example:

      # import http://example.com/rfc9999 as rfc9999

   The rule names of the ruleset to be imported may be referenced by
   prepending the alias followed by a period character ('.') followed by
   the rule name (i.e. "alias.name").  To continue the example above, if
   the ruleset at http://example.com/rfc9999 were to have a rule named
   'encoding', rules in the ruleset importing it can refer to that rule
   as 'rfc9999.encoding'.

6.  Tips and Tricks

6.1.  Any Member with Any Value

   Because member names may be specified with regular expressions, it is
   possible to construct a member rule that matches any member name:

      rule_name /.*/ target_rule_name

   As an example, the following defines an object member with any name
   that has a value that is a string:

      user_data /.*/ : string

   Constructing an object member of any name with any type would
   therefore take the form:

      rule_name /.*/ : any

6.2.  Restricting Objects

   By default, members of objects which do not match a rule are ignored.
   The reason for this validation model is due to the nature of the
   typical access model to JSON objects in many programming languages,



Newton & Cordell         Expires January 6, 2017               [Page 20]

Internet-Draft             JSON Content Rules                  July 2016


   where members of the object are obtained by referencing the member
   name.  Therefore extra members may exist without harm.

   However, some specifications may need to restrict the members of a
   JSON object to a known set.  To construct an object rule specifying
   that no extra members are expected, the @{reject} annotation may be
   used with a regular expression as the last subordinate rule of the
   object rule.

      { member1, member2, + @{reject} /.*/ : any }

   This works because subordinate rules are evaluated in the order they
   appear in the object rule, and the last rule accepts any member with
   any type but fails to validate if one ore more of those rules are
   found due to the @{reject} annotation.

6.3.  Unrestricting Arrays

   Unlike object validation, array rules will not validate items of an
   array that do not match a subordinate rule of the array rule.  This
   processing model is due to the nature of the typical access pattern
   of JSON arrays in many programming languages, which is to iterate
   over the array.  Processes iterating over an array would need to take
   special steps for extra items of the array that are not specified,
   especially if the items were of a different type than those that are
   expected.

   Like object rules, the subordinate rules of an array rule are
   evaluated in the order they appear.  To allow an array to contain any
   value after guaranteeing that it contains the necessary items, the
   last subordinate rule of the array rule should accept any item:

      [ item1, item2, * :any ]

6.4.  Groups of Values

   In addition to specific primitive data types, value rules may contain
   a value choice rule.  The value choice rule, and any subordinate rule
   within it, must evaluate to a single primitive data type.

   The following is an example of a value choice rule embedded in a
   value rule:

      address : ( :ip4 | :ip6 )







Newton & Cordell         Expires January 6, 2017               [Page 21]

Internet-Draft             JSON Content Rules                  July 2016


6.5.  Groups in Arrays

   Groups may also be a subordinate rule of array rules:

      [ ( :ip4 | :ip6 ), :integer ]

   Unlike value rules, subordinate group rules in array rules may have
   sequence combinations and contain any rule type with the exception of
   member rules.

      [ ( first_name, ? middle_name, last_name ), age ]

   Of course, the above is better written as:

      [ name, age ]

      name ( first_name, ? middle_name, last_name )

6.6.  Groups in Objects

   Groups may also be a subordinate rule of object rules:

      { ( title, date, author ), + paragraph }

   Subordinate group rules in object rules may have sequence
   combinations but must only contain member rules.

       { front_matter, + paragraph }
       front_matter ( title, date, author )
       title "title" :string
       date "date" : full-date
       author "author" [ *:string ]
       paragraph /p[0-9]*/ :string

6.7.  Group Rules as Macros

   The syntax for group rules accommodates one ore more subordinate
   rules and a repetition expression for each.  Other than grouping
   multiple rules, a group rule can be used as a macro definition for a
   single rule.

      paragraphs ( + /p[0-9]*/ : string )

6.8.  Comment Separated Rules

   Rules may be placed on the same line, but because they have no
   termination syntax this style of writing rules can be confusing to
   some readers:



Newton & Cordell         Expires January 6, 2017               [Page 22]

Internet-Draft             JSON Content Rules                  July 2016


      first_name "first name" :string last_name "last name" :string

   An empty comment can serve as a visual cue to denote the separation
   of the two rules:

      first_name "first name" :string ;; last_name "last name" :string

6.9.  Object Mixins

   Group rules can be used to create object mixins, a pattern for
   writing data models similar in style to object derivation in some
   programming languages.  In the example in Figure 3, both obj1 and
   obj2 have a members "foo" and "fob" with obj1 having the additional
   member "bar" and obj2 having the additional member "baz".

   mixin_group ( "foo" : integer, "fob" : uri )

   obj1 { mixin_group, "bar" : string }

   obj2 { mixin_group, "baz" : string }

                                 Figure 3

6.10.  Subordinate Rule Dependencies

   In object and array rules, there may be situations in which it is
   necessary to condition the existence of a subordinate rule on the
   existence of a sibling subordinate rule.  In other words,
   example_rule_two should only be evaluated if example_rule_one
   evaluates positively.  Or put another way, a member of an object or
   an item of an array may be present only on the condition that another
   member of item is present.

   In the following example, the referrer_uri member can only be present
   if the location_uri member is present.

      response { ?( location_uri, ?referrer_uri ) }

6.11.  Multiple Root Styles

   As stated in Section 4.3, the first rule in a ruleset is a root rule
   when it is unnamed.  Group rules can be used as the root rule, such
   as in the following example:

       ( { "foo" : string } | { "bar" : string } )

   This is the equivalent of the following:




Newton & Cordell         Expires January 6, 2017               [Page 23]

Internet-Draft             JSON Content Rules                  July 2016


       foo @{root} { "foo" : string }
       bar @{root} { "bar" : string }

   Either style is valid.  However, explicitly naming root rules has the
   advantage of explicitly validating a JSON message against a specific
   rule.

6.12.  JSON-like Object and Array Definitions

   JCR allows an optional colon character (":") to precede object and
   array rule definitions to give these definitions more of a JSON-like
   appearance.  Consider the following example.

       {
           "foo" {
               "fuzz" : string
            },
            "bar" [
                "baz"
            ]
        }

   To appear more JSON-like, this may also be given as follows:

       {
           "foo" : {
               "fuzz" : string
            },
            "bar" : [
                "baz"
            ]
        }

7.  ABNF Syntax

   The following ABNF describes the syntax for JSON Content Rules.

jcr              = *( sp-cmt / directive ) [ root-rule ]
                   *( sp-cmt / directive / rule )

sp-cmt           = spaces / comment
spaces           = 1*( WSP / CR / LF )
comment          = ";" *( "\;" / comment-char ) comment-end-char
comment-char     = HTAB / %x20-3A / %x3C-10FFFF
                   ; Any char other than ";" / CR / LF
comment-end-char = CR / LF / ";"

directive        = "#" (one-line-directive / multi-line-directive)



Newton & Cordell         Expires January 6, 2017               [Page 24]

Internet-Draft             JSON Content Rules                  July 2016


one-line-directive = [ spaces ]
                   (directive-def / one-line-tbd-directive-d) *WSP eol
multi-line-directive = "{" *sp-cmt
                   (directive-def / multi-line-tbd-directive-d)
                       *sp-cmt "}"
directive-def    = jcr-version-d / ruleset-id-d / import-d
jcr-version-d    = jcr-version-kw spaces major-version "." minor-version
major-version    = p-integer
minor-version    = p-integer
ruleset-id-d     = ruleset-id-kw spaces ruleset-id
import-d         = import-kw spaces ruleset-id
                   [ spaces as-kw spaces ruleset-id-alias ]
ruleset-id       = ALPHA *not-space
not-space        = %x21-10FFFF
ruleset-id-alias = name
one-line-tbd-directive-d = directive-name
                           [ WSP one-line-directive-parameters ]
directive-name   = name
one-line-directive-parameters = *not-eol
not-eol          = HTAB / %x20-10FFFF
eol              = CR / LF
multi-line-tbd-directive-d = directive-name
                   [ spaces multi-line-directive-parameters ]
multi-line-directive-parameters = multi-line-parameters
multi-line-parameters = *(comment / q-string / regex /
                   not-multi-line-special)
not-multi-line-special = spaces / %x21 / %x23-2E / %x30-3A / %x3C-7C /
                   %x7E-10FFFF ; not ", /, ; or }

root-rule        = value-rule / group-rule

rule             = rule-name *sp-cmt rule-def

rule-name        = name
target-rule-name = annotations [ ruleset-id-alias "." ] rule-name
name             = ALPHA *( ALPHA / DIGIT / "-" / "-" )

rule-def         = type-rule / member-rule / group-rule
type-rule        = value-rule / type-choice-rule / target-rule-name
value-rule       = primitive-rule / array-rule / object-rule
member-rule      = annotations
                   member-name-spec *sp-cmt type-rule
member-name-spec = regex / q-string
type-choice-rule = ":" *sp-cmt type-choice
type-choice      = annotations "(" type-choice-items
                   *( choice-combiner type-choice-items ) ")"
type-choice-items = *sp-cmt ( type-choice / type-rule ) *sp-cmt




Newton & Cordell         Expires January 6, 2017               [Page 25]

Internet-Draft             JSON Content Rules                  July 2016


annotations      = *( "@{" *sp-cmt annotation-set *sp-cmt "}" *sp-cmt )
annotation-set   = reject-annotation / unordered-annotation /
                   root-annotation / tbd-annotation
reject-annotation = reject-kw
unordered-annotation = unordered-kw
root-annotation  = root-kw
tbd-annotation   = annotation-name [ spaces annotation-parameters ]
annotation-name  = name
annotation-parameters = multi-line-parameters

primitive-rule   = annotations ":" *sp-cmt primimitive-def
primimitive-def  = null-type / boolean-type / true-value / false-value /
                   string-type / string-range / string-value /
                   float-type / float-range / float-value /
                   integer-type / integer-range / integer-value /
                   ip4-type / ip6-type / fqdn-type / idn-type /
                   uri-range / uri-type / phone-type / email-type /
                   full-date-type / full-time-type / date-time-type /
                   base64-type / any
null-type        = null-kw
boolean-type     = boolean-kw
true-value       = true-kw
false-value      = false-kw
string-type      = string-kw
string-value     = q-string
string-range     = regex
float-type       = float-kw
float-range      = float-min ".." [ float-max ] / ".." float-max
float-min        = float
float-max        = float
float-value      = float
integer-type     = integer-kw
integer-range    = integer-min ".." [ integer-max ] / ".." integer-max
integer-min      = integer
integer-max      = integer
integer-value    = integer
ip4-type         = ip4-kw
ip6-type         = ip6-kw
fqdn-type        = fqdn-kw
idn-type         = idn-kw
uri-range        = uri-dotdot-kw uri-template
uri-type         = uri-kw
phone-type       = phone-kw
email-type       = email-kw
full-date-type   = full-date-kw
full-time-type   = full-time-kw
date-time-type   = date-time-kw
base64-type      = base64-kw



Newton & Cordell         Expires January 6, 2017               [Page 26]

Internet-Draft             JSON Content Rules                  July 2016


any              = any-kw

object-rule      = annotations [ ":" *sp-cmt ]
                   "{" *sp-cmt [ object-items *sp-cmt ] "}"
object-items     = object-item (*( sequence-combiner object-item ) /
                   *( choice-combiner object-item ) )
object-item      = [ repetition *sp-cmt ] object-item-types
object-item-types = member-rule / target-rule-name / object-group
object-group     = "(" *sp-cmt [ object-items *sp-cmt ] ")"

array-rule       = annotations [ ":" *sp-cmt ]
                   "[" *sp-cmt [ array-items *sp-cmt ] "]"
array-items      = array-item (*( sequence-combiner array-item ) /
                   *( choice-combiner array-item ) )
array-item       = [ repetition ] *sp-cmt array-item-types
array-item-types = type-rule / array-group
array-group      = "(" *sp-cmt [ array-items *sp-cmt ] ")"

group-rule       = annotations "(" *sp-cmt [ group-items *sp-cmt ] ")"
group-items      = group-item (*( sequence-combiner group-item ) /
                   *( choice-combiner group-item ) )
group-item       = [ repetition ] *sp-cmt group-item-types
group-item-types = type-rule / member-rule / group-group
group-group      = group-rule

sequence-combiner = *sp-cmt "," *sp-cmt
choice-combiner  = *sp-cmt "|" *sp-cmt

repetition       = optional / one-or-more / min-max-repetition /
                   min-repetition / max-repetition /
                   zero-or-more / specific-repetition
optional         = "?"
one-or-more      = "+"
zero-or-more     = "*"
min-max-repetition = min-repeat *sp-cmt "*" *sp-cmt max-repeat
min-repetition   = min-repeat *sp-cmt "*"
max-repetition   = "*" *sp-cmt max-repeat
min-repeat       = p-integer
max-repeat       = p-integer
specific-repetition = p-integer

integer          = ["-"] 1*DIGIT
p-integer        = 1*DIGIT

float            = [ minus ] int frac [ exp ]
                   ; From RFC 7159 except 'frac' required
minus            = %x2D                          ; -
plus             = %x2B                          ; +



Newton & Cordell         Expires January 6, 2017               [Page 27]

Internet-Draft             JSON Content Rules                  July 2016


int              = zero / ( digit1-9 *DIGIT )
digit1-9         = %x31-39                       ; 1-9
frac             = decimal-point 1*DIGIT
decimal-point    = %x2E                          ; .
exp              = e [ minus / plus ] 1*DIGIT
e                = %x65 / %x45                   ; e E
zero             = %x30                          ; 0

q-string         = quotation-mark *char quotation-mark
                   ; From RFC 7159
char             = unescaped /
                   escape (
                   %x22 /          ; "    quotation mark  U+0022
                   %x5C /          ; \    reverse solidus U+005C
                   %x2F /          ; /    solidus         U+002F
                   %x62 /          ; b    backspace       U+0008
                   %x66 /          ; f    form feed       U+000C
                   %x6E /          ; n    line feed       U+000A
                   %x72 /          ; r    carriage return U+000D
                   %x74 /          ; t    tab             U+0009
                   %x75 4HEXDIG )  ; uXXXX                U+XXXX
escape           = %x5C              ; \
quotation-mark   = %x22      ; "
unescaped        = %x20-21 / %x23-5B / %x5D-10FFFF

regex            = "/" *( escape "/" / not-slash ) "/"
                   [ regex-modifiers ]
not-slash        = HTAB / CR / LF / %x20-2E / %x30-10FFFF
                   ; Any char except "/"
regex-modifiers  = *( "i" / "s" / "x" )

uri-template     = 1*ALPHA ":" 1*not-space

;; Keywords
any-kw           = %x61.6E.79                      ; "any"
as-kw            = %x61.73                         ; "as"
base64-kw        = %x62.61.73.65.36.34             ; "base64"
boolean-kw       = %x62.6F.6F.6C.65.61.6E          ; "boolean"
date-time-kw     = %x64.61.74.65.2D.74.69.6D.65    ; "date-time"
email-kw         = %x65.6D.61.69.6C                ; "email"
false-kw         = %x66.61.6C.73.65                ; "false"
float-kw         = %x66.6C.6F.61.74                ; "float"
fqdn-kw          = %x66.71.64.6E                   ; "fqdn"
full-date-kw     = %x66.75.6C.6C.2D.64.61.74.65    ; "full-date"
full-time-kw     = %x66.75.6C.6C.2D.74.69.6D.65    ; "full-time"
idn-kw           = %x69.64.6E                      ; "idn"
import-kw        = %x69.6D.70.6F.72.74             ; "import"
integer-kw       = %x69.6E.74.65.67.65.72          ; "integer"



Newton & Cordell         Expires January 6, 2017               [Page 28]

Internet-Draft             JSON Content Rules                  July 2016


ip4-kw           = %x69.70.34                      ; "ip4"
ip6-kw           = %x69.70.36                      ; "ip6"
jcr-version-kw   = %x6A.63.72.2D.76.65.72.73.69.6F.6E ; "jcr-version"
null-kw          = %x6E.75.6C.6C                   ; "null"
phone-kw         = %x70.68.6F.6E.65                ; "phone"
reject-kw        = %x72.65.6A.65.63.74             ; "reject"
root-kw          = %x72.6F.6F.74                   ; "root"
ruleset-id-kw    = %x72.75.6C.65.73.65.74.2D.69.64 ; "ruleset-id"
string-kw        = %x73.74.72.69.6E.67             ; "string"
true-kw          = %x74.72.75.65                   ; "true"
unordered-kw     = %x75.6E.6F.72.64.65.72.65.64    ; "unordered"
uri-dotdot-kw    = %x75.72.69.2E.2E                ; "uri.."
uri-kw           = %x75.72.69                      ; "uri"

;; Referenced RFC 5234 Core Rules
ALPHA            = %x41-5A / %x61-7A   ; A-Z / a-z
CR               = %x0D         ; carriage return
DIGIT            = %x30-39      ; 0-9
HEXDIG           = DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
HTAB             = %x09         ; horizontal tab
LF               = %x0A         ; linefeed
SP               = %x20         ; space
WSP              = SP / HTAB    ; white space

                   Figure 4: ABNF for JSON Content Rules

8.  Acknowledgements

   Andrew Biggs and Paul Jones provided feedback and suggestions which
   led to many changes in the syntax.

9.  References

9.1.  Normative References

   [RFC1166]  Kirkpatrick, S., Stahl, M., and M. Recker, "Internet
              numbers", RFC 1166, July 1990.

   [RFC3339]  Klyne, G., Ed. and C. Newman, "Date and Time on the
              Internet: Timestamps", RFC 3339, July 2002.

   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, "Uniform
              Resource Identifier (URI): Generic Syntax", STD 66, RFC
              3986, January 2005.

   [RFC4234]  Crocker, D., Ed. and P. Overell, "Augmented BNF for Syntax
              Specifications: ABNF", RFC 4234, October 2005.




Newton & Cordell         Expires January 6, 2017               [Page 29]

Internet-Draft             JSON Content Rules                  July 2016


   [RFC4648]  Josefsson, S., "The Base16, Base32, and Base64 Data
              Encodings", RFC 4648, October 2006.

   [RFC5322]  Resnick, P., Ed., "Internet Message Format", RFC 5322,
              October 2008.

   [RFC5952]  Kawamura, S. and M. Kawashima, "A Recommendation for IPv6
              Address Text Representation", RFC 5952, August 2010.

   [RFC6570]  Gregorio, J., Fielding, R., Hadley, M., Nottingham, M.,
              and D. Orchard, "URI Template", RFC 6570, March 2012.

   [RFC7159]  Bray, T., "The JavaScript Object Notation (JSON) Data
              Interchange Format", RFC 7159, March 2014.

9.2.  Infomative References

   [I-D.cordell-jcr-co-constraints]
              Cordell, P. and A. Newton, "Co-Constraints for JSON
              Content Rules", draft-cordell-jcr-co-constraints-00 (work
              in progress), March 2016.

   [ARIN_JCR_VALIDATOR]
              American Registry for Internet Numbers, "JSON Content
              Rules Validator (Work In Progress)",
              <https://github.com/arineng/jcrvalidator>.

   [CODALOGIC_JCR_VALIDATOR]
              Codalogic, "cl-jcr-parser (Work In Progress)",
              <https://github.com/codalogic/cl-jcr-parser>.

Appendix A.  Co-Constraints

   This specification defines a small set of annotations and directives
   for JCR, yet the syntax is extensible allowing for other annotations
   and directives.  [I-D.cordell-jcr-co-constraints] ("Co-Constraints
   for JCR") defines further annotations and directives which define
   more detailed constraints on JSON messages, including co-constraints
   (constraining parts of JSON message based on another part of a JSON
   message).

Appendix B.  Testing Against JSON Content Rules

   One aspect of JCR that differentiates it from other format schema
   languages are the mechanisms helpful to developers for taking a
   formal specification, such as that found in an RFC, and evolving it
   into unit tests, which are essential to producing quality protocol
   implementations.



Newton & Cordell         Expires January 6, 2017               [Page 30]

Internet-Draft             JSON Content Rules                  July 2016


B.1.  Locally Overriding Rules

   As mentioned in the introduction, one tool for testing would be the
   ability to locally override named rules.  As an example, consider the
   following rule which defines an array of strings.

      statuses [ * :string ]

   Consider the specification where this rule is found does not define
   the values but references an IANA registry for extensibility
   purposes.

   If a software developer desired to test a specific situation in which
   the array must at least contain the status "accepted", the rules from
   the specification could be used and the statuses rule could be
   explicitly overridden locally as:

      statuses @{unordered} [ :"accepted", * :string ]

   Alternatively, the developer may need to ensure that the status
   "denied" should not be present in the array:

      statuses @{unordered} [ ? @{reject} :"denied", * :string ]

B.2.  Rule Callbacks

   In many testing scenarios, the evaluation of rules may become more
   complex than that which can be expressed in JCR, sometimes involving
   variables and interdependencies which can only be expressed in a
   programming language.

   A JCR processor may provide a mechanism for the execution of local
   functions or methods based on the name of a rule being evaluated.
   Such a mechanism could pass to the function the data to be evaluated,
   and that function could return to the processor the result of
   evaluating the data in the function.

Appendix C.  JCR Implementations

   The following implementations, [ARIN_JCR_VALIDATOR] and
   [CODALOGIC_JCR_VALIDATOR] have influenced the development of this
   document.

Authors' Addresses







Newton & Cordell         Expires January 6, 2017               [Page 31]

Internet-Draft             JSON Content Rules                  July 2016


   Andrew Lee Newton
   American Registry for Internet Numbers
   3635 Concorde Parkway
   Chantilly, VA  20151
   US

   Email: andy@arin.net
   URI:   http://www.arin.net


   Pete Cordell
   Codalogic
   PO Box 30
   Ipswich  IP5 2WY
   UK

   Email: pete.cordell@codalogic.com
   URI:   http://www.codalogic.com

































Newton & Cordell         Expires January 6, 2017               [Page 32]
